
\title{Generalizing Positional Numeral Systems}
\author{
    Tîng-Giān Luā
}
\date{\today}

\documentclass[12pt, a4paper]{article}

% for unicode symbols
\usepackage{fontspec}
\setmonofont{DejaVu Sans Mono}

% for CJK
\usepackage{xeCJK}

\usepackage{listings}

\lstset{basicstyle=\ttfamily}

\begin{document}
\maketitle

\begin{abstract}
% Abstact [draft]
Numbers are everywhere in our daily lives, and positional numeral systems are
arguably the most important and common representation of numbers. In this work
we have constructed a generalized positional numeral system to model many of
these representations, and investigate some of their properties and relationship
with the classical unary representation of natural number.

% TODO: say more about that predicate universe stuff
\end{abstract}

\section{Introduction}

\subsection{What are numbers?}\label{num}

% Argue that what makes certain entity numbers from a structuralist perspective.

\subsection{Positional numeral systems}\label{pos}

% Different bases, different offset, different number of digits

\paragraph{Outline}
The remainder of the thesis is organized as follows.
% Section~\ref{agda} gives account of previous work.

\section{A gental introduction to dependently typed programming in Agda}\label{agda}
% [draft]

There are already plenty of tutorials and introductions of Agda\cite{norell2009dependently}\cite{FLOLAC16DTP}\cite{brutal}.
We will nonetheless compile a simple and self-contained tutorial from the materials cited above, covering the part (and only the part) we need in this work.

Some of the more advenced constructions (such as views and universes) used in
the following sections will be introduced along the way.

We assume that all readers have some basic understanding of Haskell, and those
who are familiar with Agda and dependently typed programming may skip this chapter.

\subsection{Some basics}
% [draft]
Agda is a dependently typed functional programming language based on \textbf{Martin-Löf type theory} \cite{martin1984intuitionistic}.
The first version of Agda was originally developed by Catarina Coquand at Chalmers University of Technology, the current version (Agda2) is a completely rewrite by Ulf Norell during his PhD at Chalmers.

\subsection{Simply typed programming in Agda}

% Since Agda's syntax is heavily influenced by Haskell, simply typed programming
% in Agda is almost the same as in Haskell.

\paragraph{In the beginning there was nothing}
% [draft]
Unlike in other programming languages, there are no "built-in"
datatypes such as \textit{Int}, \textit{String}, or \textit{Bool}.
The reason is that they can all be created out of thin air, so why bother?

\paragraph{Let there be datatype}
% [draft]
Datatypes are introduced with {\lstinline|data|} declarations. Here is a classical example, the type of booleans.

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

The name of the datatype ({\lstinline|Bool|}) and its constructors ({\lstinline|true|} and {\lstinline|false|}) are brought into scope.
This notation also allow us to spicify the types of these newly introduced entities explicitly.

\begin{enumerate}
    \item {\lstinline|Bool|} has the type of {\lstinline|Set|}\footnote{{\lstinline|Set|} is the type of small types, and {\lstinline|Set₁|} is the type
of {\lstinline|Set|}, and so on. They form a hierarchy of types.}
    \item {\lstinline|true|} has the type of {\lstinline|Bool|}
    \item {\lstinline|false|} has the type of {\lstinline|Bool|}
\end{enumerate}

\paragraph{Pattern matching}
% [draft]
Similar to Haskell, datatypes are eliminated with pattern matching.

Here's a function that pattern matches on {\lstinline|Bool|}.

\begin{lstlisting}
not : Bool → Bool
not true  = false
not false = true
\end{lstlisting}

Agda is a \textit{total} language, so partial functions are not allowed. Functions
are guarantee to terminate and will not crash on all possible inputs. The following
example won't be accecpted by the type checker, because the case {\lstinline|false|} is missing.

\begin{lstlisting}
not : Bool → Bool
not true  = false
\end{lstlisting}

\paragraph{Inductive datatype} Let's move on to a more interesting datatype with inductive definition. Here's the type of natural numbers.
% [draft]
\begin{lstlisting}
data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ
\end{lstlisting}

Addition on {\lstinline|ℕ|} can be defined as a recursive function.

\begin{lstlisting}
_+_ : ℕ → ℕ → ℕ
zero  + y = y
suc x + y = suc (x + y)
\end{lstlisting}

% {\lstinline|suc zero|} serves as the number "1", {\lstinline|suc (suc zero)|} as "2", and so forth.
We define {\lstinline|_+_|} by pattern matching on the first argument, which results
in two cases: the base case, and the inductive step. We are allowed to make
recursive calls, as long as the type checker is convinced that the function
would terminate.

The underlines surrounding {\lstinline|_+_|} act as placeholders for arguments, making
it an infix function in this instance.

\paragraph{Dependent functions and type arguments}
% [draft]
Up till now everything looks much the same as in Haskell, but problem arises as
we move on to defining something such as identity functions.

\begin{lstlisting}
id-Bool : Bool → Bool
id-Bool x = x

id-ℕ : ℕ → ℕ
id-ℕ x = x
\end{lstlisting}

To generalize identity functions, those concrete types have to be abstracted
away. That is, we need polymorphism, and this is where dependent types come into
play.

A dependent type is a type whose definition may depend on a value. A dependent
function is a function whose result type may depend on the value of an argument.

In Agda, function types are denoted as:
\begin{lstlisting}
A → B
\end{lstlisting}
where {\lstinline|A|} is the type of domain and {\lstinline|B|} is the type of
codomain. To make {\lstinline|B|} dependent on the value of {\lstinline|A|}, the
value has to \textit{named} as such:

\begin{lstlisting}
(x : A) → B x
\end{lstlisting}

In fact, {\lstinline|A → B|} is just a syntax sugar for {\lstinline|(_ : A) → B|}
with the names being irrelevant, the underline {\lstinline|_|} here means "don't care"

In this instance, if {\lstinline|A|} happens to be {\lstinline|Set|}, the type
of all small types, and the result type happens to be solely {\lstinline|x|}:

\begin{lstlisting}
(x : Set) → x
\end{lstlisting}

Voila, we have polymorphism. The identity function can now be defined as

\begin{lstlisting}
id : (A : Set) → A → A
id A x = x
\end{lstlisting}

{\lstinline|id|} now takes an extra argument, the type of the second arguement.
{\lstinline|id Bool true|} evaluates to {\lstinline|true|}

\paragraph{Implicit arguments}

We have implemented an identity function and saw how polymorphism can be modeled
with dependent types. However, the extra argument that the identity function
takes is actually unnecessary, since it can always be inferred by the type
checker by looking at the type of the second arguement.

Fortunately, Agda supports \textit{implicit arguments}, an syntax sugar which
allows us to hide some of the arguments, both when the function is defined and
when it is applied.

\begin{lstlisting}
id : {A : Set} → A → A
id x = x
\end{lstlisting}

Any arguments can be made implicit, but it doesn't imply that values of
implicit arguments can always be derived and recovered from other informations.
But they can be referenced or applied explicitly when neccesarily.

\begin{lstlisting}
id : {A : Set} → A → A
id {A} x = x
\end{lstlisting}

\begin{lstlisting}
id-Bool = id {Bool}
\end{lstlisting}

We could skip arrows between arguments in parentheses or braces:

\begin{lstlisting}
id : {A : Set} (a : A) → A
id {A} x = x
\end{lstlisting}

And there is a shorthand for merging names of arguments of the same type:

\begin{lstlisting}
const : {A B : Set} → A → B → A
const a _ = a
\end{lstlisting}

\paragraph{\texttt{∀}-Quantification}

There's another syntax sugar for type expressions. When the type of some value
can be inferred, we could replace {\lstinline|(A : _)|} with {\lstinline|∀ A|} and
 {\lstinline|{A : _}|} with {\lstinline|∀ {A}|}.



\paragraph{With abstraction}
% views, decidabal predicates
% list

\paragraph{Absurd pattern}
% Bottom type, contradiction


\subsection{Dependently typed programming in Agda}


\section{Num : a representation for positional numeral systems}\label{representation}

\subsection{Bases}
\subsection{Offsets}
\subsection{Number of digits}

\section{Properties of Num}
\subsection{Maximum}
\subsection{Bounded}
\subsection{Bounded}
\subsection{Views}

\section{Conclusions}\label{conclusions}

\bibliographystyle{abbrv}
\bibliography{thesis}
\end{document}
