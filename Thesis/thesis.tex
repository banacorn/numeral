
\title{Generalizing Positional Numeral Systems}
\author{
    Tîng-Giān Luā
}
\date{\today}

\documentclass[12pt, a4paper]{article}

% for unicode symbols
\usepackage{fontspec}

% for CJK
\usepackage{xeCJK}

\usepackage{listings}

\lstset{basicstyle=\ttfamily}

\begin{document}
\maketitle

\begin{abstract}
% Abstact [draft]
Numbers are everywhere in our daily lives, and positional numeral systems are
arguably the most important and common representation of numbers. In this work
we have constructed a generalized positional numeral system to model many of
these representations, and investigate some of their properties and relationship
with the classical unary representation of natural number.

% TODO: say more about that predicate universe stuff
\end{abstract}

\section{Introduction}

\subsection{What are numbers?}\label{num}

% Argue that what makes certain entity numbers from a structuralist perspective.

\subsection{Positional numeral systems}\label{pos}

% Different bases, different offset, different number of digits

\paragraph{Outline}
The remainder of the thesis is organized as follows.
% Section~\ref{agda} gives account of previous work.

\section{A gental introduction to dependently typed programming in Agda}\label{agda}

There are already plenty of tutorials and introductions of Agda\cite{norell2009dependently}\cite{FLOLAC16DTP}\cite{brutal}.
We will nonetheless compile a simple and self-contained tutorial from the materials cited above, covering the part (and only the part) we need in this work.

Some of the more advenced constructions (such as views and universes) used in
the following sections will be introduced along the way.

We assume that all readers have some basic understanding of Haskell, and those
who are familiar with Agda and dependently typed programming may skip this chapter.

\subsection{Some basics}

Agda is a dependently typed functional programming language based on \textbf{Martin-Löf type theory} \cite{martin1984intuitionistic}.
The first version of Agda was originally developed by Catarina Coquand at Chalmers University of Technology, the current version (Agda2) is a completely rewrite by Ulf Norell during his PhD at Chalmers.

\subsection{Simply typed programming in Agda}

% Since Agda's syntax is heavily influenced by Haskell, simply typed programming
% in Agda is almost the same as in Haskell.

\paragraph{In the beginning there was nothing}

Unlike in other programming languages, there are no "built-in"
datatypes such as \textit{Int}, \textit{String}, or \textit{Bool}.
The reason is that they can all be created out of thin air, so why bother?

\paragraph{Let there be datatype}

Datatypes are introduced with {\lstinline|data|} declarations. Here is a classical example, the type of booleans.

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

The name of the datatype ({\lstinline|Bool|}) and its constructors ({\lstinline|true|} and {\lstinline|false|}) are brought into scope.
This notation also allow us to spicify the types of these newly introduced entities explicitly.

\begin{enumerate}
    \item {\lstinline|Bool|} has the type of {\lstinline|Set|}\footnote{{\lstinline|Set|} is the type of small types, and {\lstinline|Set₁|} is the type
of {\lstinline|Set|}, and so on. They form a hierarchy of types.}
    \item {\lstinline|true|} has the type of {\lstinline|Bool|}
    \item {\lstinline|false|} has the type of {\lstinline|Bool|}
\end{enumerate}

\paragraph{Pattern matching}

Similar to Haskell, datatypes are eliminated with pattern matching.

Here's a function that pattern matches on {\lstinline|Bool|}.

\begin{lstlisting}
not : Bool → Bool
not true  = false
not false = true
\end{lstlisting}

Agda is a \textit{total} language, so partial functions are not allowed. Functions
are guarantee to terminate and will not crash on all possible inputs. The following
example won't be accecpted by the type checker, because the case {\lstinline|false|} is missing.

\begin{lstlisting}
not : Bool → Bool
not true  = false
\end{lstlisting}

\paragraph{Inductive datatype} Let's move on to a more interesting datatype with inductive definition. Here's the type of natural numbers.

\begin{lstlisting}
data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ
\end{lstlisting}

Addition on {\lstinline|ℕ|} can be defined as a recursive function.

\begin{lstlisting}
_+_ : ℕ → ℕ → ℕ
zero  + y = y
suc x + y = suc (x + y)
\end{lstlisting}

% {\lstinline|suc zero|} serves as the number "1", {\lstinline|suc (suc zero)|} as "2", and so forth.
We define {\lstinline|_+_|} by pattern matching on the first argument, which results
in two cases: the base case, and the inductive step. We are allowed to make
recursive calls, as long as the type checker is convinced that the function
would terminate.

The underlines surrounding {\lstinline|_+_|} act as placeholders for arguments, making
it an infix function in this instance.

\paragraph{Dependent functions}
Up till now everything looks much the same as in Haskell, but as we move on to
defining something that needs more power of abstraction, dependent types
come into play.

Take identity functions for example:

\begin{lstlisting}
identity-Bool : Bool → Bool
identity-Bool x = x

identity-ℕ : ℕ → ℕ
identity-ℕ x = x
\end{lstlisting}

If we want to generalize these two identity functions of different types, those
types have to be abstracted away.



\paragraph{With abstraction}
% views, decidabal predicates

\paragraph{Absurd pattern}
% Bottom type, contradiction


\subsection{Dependently typed programming in Agda}


\section{Num : a representation for positional numeral systems}\label{representation}

\subsection{Bases}
\subsection{Offsets}
\subsection{Number of digits}

\section{Properties of Num}
\subsection{Maximum}
\subsection{Bounded}
\subsection{Bounded}
\subsection{Views}

\section{Conclusions}\label{conclusions}

\bibliographystyle{abbrv}
\bibliography{thesis}
\end{document}
