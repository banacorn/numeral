
\title{Some title}
\author{
    Someone
}
\date{\today}

\documentclass[12pt, a4paper]{article}

% for unicode symbols
\usepackage{fontspec}

% for CJK
\usepackage{xeCJK}

\usepackage{listings}

\lstset{basicstyle=\ttfamily}

\begin{document}
\maketitle

\begin{abstract}
This is the paper's abstract \ldots
\end{abstract}

\section{Introduction}

% Numbers are everywhere in our daily lives.

\subsection{What are numbers?}\label{num}

% Argue that what makes certain entity numbers from a structuralist perspective.

\subsection{Positional numeral systems}\label{pos}


\paragraph{Outline}
The remainder of the thesis is organized as follows.
% Section~\ref{agda} gives account of previous work.

\section{A gental introduction to dependently typed programming in Agda}\label{agda}

There are already plenty of tutorials and introductions of Agda\cite{norell2009dependently}\cite{FLOLAC16DTP}\cite{brutal}.
We will nonetheless compile a simple and self-contained tutorial from the materials cited above, covering the part (and only the part) we need in this work.

Some of the more advenced constructions (such as views and universes) used in
the following sections will be introduced along the way.

We assume that all readers have some basic understanding of Haskell, and those
who are familiar with Agda and dependently typed programming may skip this chapter.

\subsection{Some basics}

Agda is a dependently typed functional programming language based on \textbf{Martin-Löf type theory} \cite{martin1984intuitionistic}.
The first version of Agda was originally developed by Catarina Coquand at Chalmers University of Technology, the current version (Agda2) is a completely rewrite by Ulf Norell during his PhD at Chalmers.

\subsection{Simply typed programming in Agda}

% Since Agda's syntax is heavily influenced by Haskell, simply typed programming
% in Agda is almost the same as in Haskell.

\paragraph{In the beginning there was nothing}

Unlike in other programming languages, there are no "built-in"
datatypes such as \textit{Int}, \textit{String}, or \textit{Bool}.
The reason is that they can all be created out of thin air, so why bother?

\paragraph{Let there be datatype}

Datatypes are introduced with {\lstinline|data|} declarations. Here is a classical example, the type of booleans.

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

The name of the datatype ({\lstinline|Bool|}) and its constructors ({\lstinline|true|} and {\lstinline|false|}) are brought into scope.
This notation also allow us to spicify the types of these newly introduced entities explicitly.

\begin{enumerate}
    \item {\lstinline|Bool|} has the type of {\lstinline|Set|}\footnote{{\lstinline|Set|} is the type of small types, and {\lstinline|Set₁|} is the type
of {\lstinline|Set|}, and so on. They form a hierarchy of types.}
    \item {\lstinline|true|} has the type of {\lstinline|Bool|}
    \item {\lstinline|false|} has the type of {\lstinline|Bool|}
\end{enumerate}

\paragraph{Pattern matching}

Similar to Haskell, datatypes are eliminated with pattern matching.

Here's a function that pattern matches on {\lstinline|Bool|}.

\begin{lstlisting}
not : Bool → Bool
not true  = false
not false = true
\end{lstlisting}

Agda is a \textit{total} language, so partial functions are not allowed. Functions
are guarantee to terminate and will not crash on all possible inputs. The following
example won't be accecpted by the type checker, because the case {\lstinline|false|} is missing.

\begin{lstlisting}
not : Bool → Bool
not true  = false
\end{lstlisting}

\paragraph{Inductive datatype} Let's move on to a more interesting datatype with inductive definition. Here's the type of natural numbers.

\begin{lstlisting}
data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ
\end{lstlisting}




Note that the symbol ℕ is not some typographic ligature used to make this thesis
look prettier. Unicode symbols are used extensively in Agda

\subsection{Dependently typed programming in Agda}


\section{Num : a representation for positional numeral systems}\label{representation}

\subsection{Bases}
\subsection{Offsets}
\subsection{Number of digits}

\section{Properties of Num}
\subsection{Maximum}
\subsection{Bounded}
\subsection{Bounded}
\subsection{Views}

\section{Conclusions}\label{conclusions}

\bibliographystyle{abbrv}
\bibliography{thesis}
\end{document}
