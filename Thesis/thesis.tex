
\title{Some title}
\author{
    Someone
}
\date{\today}

\documentclass[12pt, a4paper]{article}

% for unicode symbols
\usepackage{fontspec}

% for CJK
\usepackage{xeCJK}

\usepackage{listings}

\lstset{basicstyle=\ttfamily}

\begin{document}
\maketitle

\begin{abstract}
This is the paper's abstract \ldots
\end{abstract}

\section{Introduction}

% Numbers are everywhere in our daily lives.

\subsection{What are numbers?}\label{num}

% Argue that what makes certain entity numbers from a structuralist perspective.

\subsection{Positional numeral systems}\label{pos}


\paragraph{Outline}
The remainder of the thesis is organized as follows.
% Section~\ref{agda} gives account of previous work.

\section{A gental introduction to dependently typed programming in Agda}\label{agda}

There are already plenty of tutorials and introductions of Agda\cite{norell2009dependently}.
Nonetheless, we will provide a simple and self-contained tutorial in this section,
covering the part (and only the part) we need in this work.

Some of the more advenced constructions (such as views and universes) used in
the following sections will be introduced along the way.

We assume that all readers have some basic understanding of Haskell, and those
who are familiar with Agda and dependently typed programming may skip this chapter.

\subsection{Some basics}

Agda is a dependently typed functional programming language based on 


, and also a interactive
theorem prover.



\subsection{Dependent types}

\subsection{Simply typed programming in Agda}

% Since Agda's syntax is heavily influenced by Haskell, simply typed programming
% in Agda is almost the same as in Haskell.

\paragraph{In the beginning there was nothing}

Unlike in other programming languages, there are no "built-in"
datatypes\footnote{Small types, to be precise} such as \textit{Int}, \textit{String}, or \textit{Bool}.
The reason is that they can all be created out of thin air, so why bother?

\paragraph{Let there be datatype}

Datatypes are introduced with {\lstinline|data|} declarations. Here is a classical example, the type of booleans.

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

Three names are brought into scope:

\begin{enumerate}
    \item {\lstinline|Bool|}: the name of the datatype
    \item {\lstinline|true|}: a constructor of the datatype
    \item {\lstinline|false|}: another constructor of the datatype
\end{enumerate}

The declaration also explicitly spicifies the types of these newly introduced entities.

\begin{enumerate}
    \item {\lstinline|Bool|} has the type of {\lstinline|Set|}\footnote{{\lstinline|Set|} is the type of small types, and {\lstinline|Set₁|} is the type
of {\lstinline|Set|}, and so on. They form a hierarchy of types.}
    \item {\lstinline|true|} has the type of {\lstinline|Bool|}
    \item {\lstinline|false|} has the type of {\lstinline|Bool|}
\end{enumerate}

\paragraph{Pattern matching}

Similar to Haskell, datatypes are eliminated with pattern matching.

Here's a function that pattern matches on {\lstinline|Bool|}.

\begin{lstlisting}
not : Bool → Bool
not true  = false
not false = true
\end{lstlisting}





\subsection{Dependently typed programming in Agda}


\section{Representing positional numeral systems}\label{representation}

\subsection{Bases}
\subsection{Offsets}
\subsection{Number of digits}

\section{Properties of Num}
\subsection{Categorizing Num}
\subsection{Views}

\section{Conclusions}\label{conclusions}

\bibliographystyle{abbrv}
\bibliography{thesis}
\end{document}
