\documentclass[../thesis.tex]{subfiles}
\begin{document}
\chapter{Constructions [still writing]} 
%  [draft]

The representation for positional numeral systems in Agda will be constructed in this
chapter, along with the generalizations introduced in section~\ref{generalizations}.

\begin{itemize}
    \item \textbf{base}: the base of a numeral system, denoted {\lstinline|b|}.
    \item \textbf{\#digit}: the number of digits, denoted {\lstinline|d|}.
    \item \textbf{offset}: the number where the digits starts from, denoted {\lstinline|o|}.
\end{itemize}

\section{Digit: the basic building block}\label{digit}
% [draft]

As the basic building block of numerals, we will demonstrate how to choose a
suitable representation for digits in this section.

\subsection{Fin}

To represent a digit, we use a datatype that is conventionally called \textit{Fin}
which can be indexed to have some exact number of inhabitants.

\begin{lstlisting}
data Fin : ℕ → Set where
    zero : {n : ℕ} → Fin (suc n)
    suc  : {n : ℕ} (i : Fin n) → Fin (suc n)
\end{lstlisting}

The definition of {\lstinline|Fin|} looks the same as {\lstinline|ℕ|} on the term
level, but different on the type level. The index of a {\lstinline|Fin|} increases
with every {\lstinline|suc|}, and there can only be at most {\lstinline|n|} of
them before reaching {\lstinline|Fin (suc n)|}. In other words, {\lstinline|Fin n|}
would have exactly \textit{n} inhabitants.

\subsection{Definition}

{\lstinline|Digit|} is simply just a synonym for {\lstinline|Fin|}, indexed by
the number of digits {\lstinline|d|} of a system.
Since the same digit may represent different values in different numeral systems,
it is essential to make the context clear.

\begin{lstlisting}
Digit : ℕ → Set
Digit d = Fin d
\end{lstlisting}

Ordinary binary digits for example can thus be represented as:

\begin{lstlisting}
Binary : Set
Binary = Digit 2

零 : Binary
零 = zero

一 : Binary
一 = suc zero
\end{lstlisting}

\subsection{Digit Assignment}

\begin{center}
    \begin{tikzpicture}
        % a straight line segment
        \draw (0, 0) -- (10, 0);
        % the ticks and their labels
        \draw[xshift=0cm] (0pt,2pt) -- (0pt,-1pt) node[below,fill=white] {\the\numexpr0};
        % \foreach \x  in {0,...,10}
        %   \draw[xshift=\x cm] (0pt,2pt) -- (0pt,-1pt) node[below,fill=white] {\the\numexpr\x\relax};
        % the thicker segment
        \draw[ultra thick] (1,0) -- (9,0);
        % the labels
        \node[fill=white,draw=black,circle,inner sep=2pt,label=above:{$o$}] at (1,0) {};
        \node[fill=white,draw=black,circle,inner sep=2pt,label=above:{$d+o$}] at (9,0) {};
        \node at (5, -0.5) {{\lstinline|ℕ|}};
    \end{tikzpicture}
\end{center}

Digits are assigned to {\lstinline|ℕ|} together with the offset {\lstinline|o|} of a system,
ranging from $ o $ to $ d + o $.
\footnote{
    {\lstinline|toℕ : ∀ {n} → Fin n → ℕ|}
    \newline\hspace*{4em} converts from {\lstinline|Fin n|} to {\lstinline|ℕ|}.
}

\begin{lstlisting}
Digit-toℕ : ∀ {d} → Digit d → ℕ → ℕ
Digit-toℕ x o = toℕ x + o
\end{lstlisting}



%
% \begin{itemize}
%     \item {\lstinline|toℕ : ∀ {n} → Fin n → ℕ|}
%         \\ converts from {\lstinline|Fin n|} to {\lstinline|ℕ|}.
% \end{itemize}

However, not all natural numbers can be converted to digits.
The value has to be in a certain range, between $ o $ and $ d + o $.
Values less than $ o $ are increased to $ o $.
Values greater than $ d + o $ are prohibited by the supplied upper-bound.

\begin{lstlisting}
Digit-fromℕ : ∀ {d}
    → (n o : ℕ)
    → (upper-bound : d + o ≥ n)
    → Digit (suc d)
Digit-fromℕ {d} n o upper-bound with n ∸ o ≤? d
Digit-fromℕ {d} n o upper-bound | yes p = fromℕ≤ (s≤s p)
Digit-fromℕ {d} n o upper-bound | no ¬p = contradiction p ¬p
    where   p : n ∸ o ≤ d
            p = start
                    n ∸ o
                ≤⟨ ∸n-mono o upper-bound ⟩
                    (d + o) ∸ o
                ≈⟨ m+n∸n≡m d o ⟩
                    d
                □
\end{lstlisting}

\begin{itemize}
    \item {\lstinline|fromℕ≤ : ∀ {m n} → m < n → Fin n|}
        \\ converts from {\lstinline|ℕ|} to {\lstinline|Fin n|} given the number is small enough.
\end{itemize}


\paragraph{Properties of Digits}
{\lstinline|Digit-fromℕ-toℕ|} states that the value of a natural number should
remain the same, after converting back and forth between {\lstinline|Digit|} and
{\lstinline|ℕ|}.

\begin{lstlisting}
Digit-fromℕ-toℕ : ∀ {d o}
    → (n : ℕ)
    → (lower-bound :     o ≤ n)
    → (upper-bound : d + o ≥ n)
    → Digit-toℕ (Digit-fromℕ {d} n o upper-bound) o ≡ n
Digit-fromℕ-toℕ {d} {o} n lb ub with n ∸ o ≤? d
Digit-fromℕ-toℕ {d} {o} n lb ub | yes q =
    begin
        toℕ (fromℕ≤ (s≤s q)) + o
    ≡⟨ cong (λ x → x + o) (toℕ-fromℕ≤ (s≤s q)) ⟩
        n ∸ o + o
    ≡⟨ m∸n+n≡m lb ⟩
        n
    ∎
Digit-fromℕ-toℕ {d} {o} n lb ub | no ¬q = contradiction q ¬q
    where   q : n ∸ o ≤ d
            q = +n-mono-inverse o (
                start
                    n ∸ o + o
                ≈⟨ m∸n+n≡m lb ⟩
                    n
                ≤⟨ ub ⟩
                    d + o
                □)
\end{lstlisting}

\begin{itemize}
    \item {\lstinline|toℕ-fromℕ≤ : ∀ {m n} (m<n : m < n) → toℕ (fromℕ≤ m<n) ≡ m|}
        \\ states that a number should remain the same after converting back and forth.
\end{itemize}

Digits have a upper-bound and a lower-bound after evaluation.

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
Digit-upper-bound : ∀ {d} → (o : ℕ) → (x : Digit d) → Digit-toℕ x o < d + o
Digit-upper-bound {d} o x = +n-mono o (bounded x)

Digit-lower-bound : ∀ {d} → (o : ℕ) → (x : Digit d) → Digit-toℕ x o ≥ o
Digit-lower-bound {d} o x = m≤n+m o (toℕ x)
\end{lstlisting}

\begin{itemize}
    \item {\lstinline|bounded : ∀ {n} (i : Fin n) → toℕ i < n|}
        \\ a property about the upper-bound of a {\lstinline|Fin n|}.
\end{itemize}

\subsection{Special Digits}

\subsubsection{The Greatest Digit}

\paragraph{constructions}

The greatest digit of a system is constructed by converting the index {\lstinline|d|}
to {\lstinline|Fin|}.

\begin{lstlisting}
greatest-digit : ∀ d → Digit (suc d)
greatest-digit d = fromℕ d
\end{lstlisting}

\begin{itemize}
    \item {\lstinline|fromℕ : ∀ {n} → Fin n → ℕ|}
        \\ construct the greatest possible {\lstinline|Fin n|} when given an index {\lstinline|n|}.
\end{itemize}

\paragraph{predicates}

Judging whether a digit is the greatest by converting it to {\lstinline|ℕ|}.
This predicate also comes with a decidable version.

\begin{lstlisting}
Greatest : ∀ {d} (x : Digit d) → Set
Greatest {d} x = suc (toℕ x) ≡ d

Greatest? : ∀ {d} (x : Digit d) → Dec (Greatest x)
Greatest? {d} x = suc (toℕ x) ≟ d
\end{lstlisting}

\paragraph{properties}

Converting from the greatest digit to {\lstinline|ℕ|} should result in {\lstinline|d + o|}.

\begin{lstlisting}
greatest-digit-toℕ : ∀ {d o}
    → (x : Digit (suc d))
    → Greatest x
    → Digit-toℕ x o ≡ d + o
greatest-digit-toℕ {d} {o} x greatest = cancel-suc (
    begin
        suc (Digit-toℕ x o)
    ≡⟨ refl ⟩
        suc (toℕ x) + o
    ≡⟨ cong (λ w → w + o) greatest ⟩
        suc d + o
    ∎)
\end{lstlisting}

A digit is the greatest if and only if it is greater than or equal to all other
digits. This proposition is proven by induction on both of the compared digits.

\begin{lstlisting}
greatest-of-all : ∀ {d} (o : ℕ) → (x y : Digit d)
    → Greatest x
    → Digit-toℕ x o ≥ Digit-toℕ y o
greatest-of-all o zero    zero     refl     = ≤-refl
greatest-of-all o zero    (suc ()) refl
greatest-of-all o (suc x) zero     greatest
    = +n-mono o {zero} {suc (toℕ x)} z≤n
greatest-of-all o (suc x) (suc y)  greatest
    = s≤s (greatest-of-all o x y (cancel-suc greatest))
\end{lstlisting}

\subsubsection{The Carry}

A carry is a digit that is transferred to a more significant digit to compensate
the ``loss'' of the original digit.

\paragraph{constructions}

The carry is defined as the greater of these two values:

\begin{itemize}
    \item the least digit of a system
    \item the digit that is assigned to $ 1 $
\end{itemize}

In case that that the least digit is assigned to $ 0 $, rendering the carry useless.
Since the least digit is determined by the offset $ o $, the value of the carry
is defined as follows.

\begin{lstlisting}
carry : ℕ → ℕ
carry o = 1 ⊔ o
\end{lstlisting}

And then we construct the carry by converting {\lstinline|carry o|} to {\lstinline|Digit|}:

\begin{lstlisting}
carry-digit : ∀ d o → 2 ≤ suc d + o → Digit (suc d)
carry-digit d o proper =
    Digit-fromℕ
        (carry o)
        o
        (carry-upper-bound {d} proper)
\end{lstlisting}

\paragraph{properties}

The value of the carry should remain the same after converting back and forth.

\begin{lstlisting}
carry-digit-toℕ : ∀ d o
    → (proper : 2 ≤ suc (d + o))
    → Digit-toℕ (carry-digit d o proper) o ≡ carry o
carry-digit-toℕ d o proper
    = Digit-fromℕ-toℕ
        (carry o)
        (m≤n⊔m o 1)
        (carry-upper-bound {d} proper)
\end{lstlisting}

The carry also have an upper-bound and a lower-bound, similar to that of {\lstinline|Digit|}.

\begin{lstlisting}
carry-lower-bound : ∀ {o} → carry o ≥ o
carry-lower-bound {o} = m≤n⊔m o 1

carry-upper-bound : ∀ {d o} → 2 ≤ suc d + o → carry o ≤ d + o
carry-upper-bound {d} {zero}  proper = ≤-pred proper
carry-upper-bound {d} {suc o} proper = n≤m+n d (suc o)
\end{lstlisting}

\section{Num: a representation for positional numeral systems}\label{representation}

\subsection{Definition}

Numerals in positional numeral systems are composed of sequences of digits.
So the definition of {\lstinline|Numeral|} will be similar to that of {\lstinline|List|},
except that a {\lstinline|Numeral|} must contain at least one digit while a list
may contain no elements at all. The most significant digit is placed in {\lstinline|_∙|}
while the least significant digit is placed at the end of the sequence.
{\lstinline|Numeral|} is indexed by all three generalizations.

\begin{lstlisting}
infixr 5 _∷_

data Numeral : ℕ → ℕ → ℕ → Set where
    _∙  : ∀ {b d o} → Digit d → Numeral b d o
    _∷_ : ∀ {b d o} → Digit d → Numeral b d o → Numeral b d o
\end{lstlisting}

The decimal number ``2016'' for example can be represented as:

\begin{lstlisting}
MMXVI : Numeral 10 10 0
MMXVI = # 6 ∷ # 1 ∷ # 0 ∷ (# 2) ∙
\end{lstlisting}

Where {\lstinline|#_ : ∀ m {n} {m<n : True (suc m ≤? n)} → Fin n|} converts from
{\lstinline|ℕ|} to {\lstinline|Fin n|} given the number is small enough.

\subsection{Converting to natural numbers}

Converting to natural numbers is fairly trivial.

\begin{lstlisting}
⟦_⟧ : ∀ {b d o} → (xs : Numeral b d o) → ℕ
⟦_⟧ {_} {_} {o} (x ∙)    = Digit-toℕ x o
⟦_⟧ {b} {_} {o} (x ∷ xs) = Digit-toℕ x o + ⟦ xs ⟧ * b
\end{lstlisting}

% TODO: discuss the relation between Numeral and ℕ

\section{Dissecting Numeral Systems with Views}\label{views}

There are many kinds of numeral systems inhabit in {\lstinline|Numeral|}.
These systems have different interesting properties and they should be treated
differently, so we sort them into \textbf{four categories} accordingly.

\paragraph{Systems with no digits at all}

The number of digits of a system is determined by the index {\lstinline|d|}.
If {\lstinline|d|} happens to be $ 0 $, then there will be no digits in any of
these systems. Although they seem useless, these systems have plenty of properties.
Since there are not digits at all, any property that is related to digits would
hold vacuously.

\paragraph{Systems with the base of $ 0 $}

If {\lstinline|b|}, the base of a system, happens to be $ 0 $,
then only the least significant digit would have effects on the evaluation,
because the rest of the digits would diminish into nothing.

\begin{lstlisting}
⟦ x ∙    ⟧ = Digit-toℕ x o
⟦ x ∷ xs ⟧ = Digit-toℕ x o + ⟦ xs ⟧ * 0
\end{lstlisting}

\paragraph{Systems with only zeros}

Consider when {\lstinline|d|} is set to $ 1 $ and {\lstinline|o|} set to $ 0 $.
There will be one digit but the only digit is assigned to $ 0 $.

\begin{lstlisting}
0, 00, 000, 0000, ...
\end{lstlisting}

As a result, every numeral would evaluate to $ 0 $ regardless of the base.

\paragraph{``Proper'' systems}

The rest of systems that does not fall into any of the categories above
are considered \textit{proper}.

\subsection{Categorizing Systems}

These ``categories'' are represented with a datatype called {\lstinline|NumView|}
that is indexed by the three indices: {\lstinline|b|}, {\lstinline|d|}, and {\lstinline|o|}.

\begin{lstlisting}
data NumView : (b d o : ℕ) → Set where
    NullBase    : ∀   d o → NumView 0       (suc d) o
    NoDigits    : ∀ b o   → NumView b       0       o
    AllZeros    : ∀ b     → NumView (suc b) 1       0
    Proper      : ∀ b d o → (proper : suc d + o ≥ 2)
                          → NumView (suc b) (suc d) o
\end{lstlisting}

By pattern matching on indices, different configurations of indices are sorted into
different {\lstinline|NumView|}s.

\begin{lstlisting}
numView : ∀ b d o → NumView b d o
numView b       zero          o       = NoDigits b o
numView zero    (suc d)       o       = NullBase d o
numView (suc b) (suc zero)    zero    = AllZeros b
numView (suc b) (suc zero)    (suc o) = Proper b zero (suc o) _
numView (suc b) (suc (suc d)) o       = Proper b (suc d) o _
\end{lstlisting}

Together with \textit{with-abstractions}, we can, for example, define a function
to determine whether a numeral system is boring or not:

\begin{lstlisting}
boring : ∀ b d o → Bool
boring b d o with numView b d o
boring _ _ _ | NullBase d o         = false
boring _ _ _ | NoDigits b o         = false
boring _ _ _ | AllZeros b           = false
boring _ _ _ | Proper b d o proper  = true
\end{lstlisting}

As we can see, the function {\lstinline|numView|} does more than sorting indices
into different categories. It also reveals relevant infomation and properties
about these categories. For instance, if a system {\lstinline|Numeral b d o|}
is classified as \textit{Proper}, then we know that:

\begin{itemize}
    \item {\lstinline|b|} is greater than $ 0 $.
    \item {\lstinline|d|} is also greater than $ 0 $.
    \item {\lstinline|o|} can be any value as long as {\lstinline|d + o ≥ 2|}.
\end{itemize}

\subsection{Views}

The sole purpose of {\lstinline|NumView|} is to sort out and expose some
interesting properties about its indices.
Such datatypes are called \textit{views}\cite{wadler1987views} as they present
different aspects of the same entity. Functions like {\lstinline|numView|} are
called \textit{view functions} or \textit{eliminators}\cite{mcbride2004views}
because they provide different ways of eliminating a datatype.

Views are like special lenses that are customized to our needs, and they are
\textit{reusable} which frees us from having to pattern match on the same
indices or data again and again.

We will define more views and use them extensively in the coming sections.

\subsection{Maximum}
\subsection{Bounded}
\subsection{Next}
\subsection{Increment}
\subsection{Continuous}


% \subsection{Maximum}
%
% A number is said to be \textit{maximum} if there are no other number greater than
% itself.
%
% \begin{lstlisting}
% Maximum : ∀ {b d o} → (xs : Numeral b d o) → Set
% Maximum {b} {d} {o} xs = ∀ (ys : Numeral b d o) → ⟦ xs ⟧ ≥ ⟦ ys ⟧
% \end{lstlisting}
%
%
% \section{Conclusions}\label{conclusions}

\end{document}
