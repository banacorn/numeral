\providecommand{\main}{..}
\documentclass[\main/thesis.tex]{subfiles}
\begin{document}
\chapter{Constructions [still writing]}
%  [draft]

The representation for positional numeral systems in Agda will be constructed in this
chapter, along with the generalizations introduced in section~\ref{generalizations}.

\begin{itemize}
    \item \textbf{base}: the base of a numeral system, denoted {\lstinline|b|}.
    \item \textbf{\#digit}: the number of digits, denoted {\lstinline|d|}.
    \item \textbf{offset}: the number where the digits starts from, denoted {\lstinline|o|}.
\end{itemize}

\subfile{\main/tex/constructions/digit.tex}

\section{Num: a representation for positional numeral systems}\label{representation}

\subsection{Definition}

Numerals in positional numeral systems are composed of sequences of digits.
So the definition of {\lstinline|Numeral|} will be similar to that of {\lstinline|List|},
except that a {\lstinline|Numeral|} must contain at least one digit while a list
may contain no elements at all. The most significant digit is placed in {\lstinline|_∙|}
while the least significant digit is placed at the end of the sequence.
{\lstinline|Numeral|} is indexed by all three generalizations.

\begin{lstlisting}
infixr 5 _∷_

data Numeral : ℕ → ℕ → ℕ → Set where
    _∙  : ∀ {b d o} → Digit d → Numeral b d o
    _∷_ : ∀ {b d o} → Digit d → Numeral b d o → Numeral b d o
\end{lstlisting}

The decimal number ``2016'' for example can be represented as:

\begin{lstlisting}
MMXVI : Numeral 10 10 0
MMXVI = # 6 ∷ # 1 ∷ # 0 ∷ (# 2) ∙
\end{lstlisting}

Where {\lstinline|#_ : ∀ m {n} {m<n : True (suc m ≤? n)} → Fin n|} converts from
{\lstinline|ℕ|} to {\lstinline|Fin n|} given the number is small enough.

To extract the least significant digit from a numeral:

\begin{lstlisting}
lsd : ∀ {b d o} → (xs : Numeral b d o) → Digit d
lsd (x ∙   ) = x
lsd (x ∷ xs) = x
\end{lstlisting}

\subsection{Converting to natural numbers}

Converting to natural numbers is fairly trivial.

\begin{lstlisting}
⟦_⟧ : ∀ {b d o} → (xs : Numeral b d o) → ℕ
⟦_⟧ {_} {_} {o} (x ∙)    = Digit-toℕ x o
⟦_⟧ {b} {_} {o} (x ∷ xs) = Digit-toℕ x o + ⟦ xs ⟧ * b
\end{lstlisting}

% TODO: discuss the relation between Numeral and ℕ

\section{Dissecting Numeral Systems with Views}\label{views}

There are many kinds of numeral systems inhabit in {\lstinline|Numeral|}.
These systems have different interesting properties and they should be treated
differently, so we sort them into \textbf{four categories} accordingly.

\paragraph{Systems with no digits at all}

The number of digits of a system is determined by the index {\lstinline|d|}.
If {\lstinline|d|} happens to be $ 0 $, then there will be no digits in any of
these systems. Although they seem useless, these systems have plenty of properties.
Since there are not digits at all, any property that is related to digits would
hold vacuously.

\paragraph{Systems with the base of $ 0 $}

If {\lstinline|b|}, the base of a system, happens to be $ 0 $,
then only the least significant digit would have effects on the evaluation,
because the rest of the digits would diminish into nothing.

\begin{lstlisting}
⟦ x ∙    ⟧ = Digit-toℕ x o
⟦ x ∷ xs ⟧ = Digit-toℕ x o + ⟦ xs ⟧ * 0
\end{lstlisting}

\paragraph{Systems with only zeros}

Consider when {\lstinline|d|} is set to $ 1 $ and {\lstinline|o|} set to $ 0 $.
There will be one digit but the only digit is assigned to $ 0 $.

\begin{lstlisting}
0, 00, 000, 0000, ...
\end{lstlisting}

As a result, every numeral would evaluate to $ 0 $ regardless of the base.

\paragraph{``Proper'' systems}

The rest of systems that does not fall into any of the categories above
are considered \textit{proper}.

\subsection{Categorizing Systems}

These ``categories'' are represented with a datatype called {\lstinline|NumView|}
that is indexed by the three indices: {\lstinline|b|}, {\lstinline|d|}, and {\lstinline|o|}.

\begin{lstlisting}
data NumView : (b d o : ℕ) → Set where
    NullBase    : ∀   d o → NumView 0       (suc d) o
    NoDigits    : ∀ b o   → NumView b       0       o
    AllZeros    : ∀ b     → NumView (suc b) 1       0
    Proper      : ∀ b d o → (proper : suc d + o ≥ 2)
                          → NumView (suc b) (suc d) o
\end{lstlisting}

By pattern matching on indices, different configurations of indices are sorted into
different {\lstinline|NumView|}s.

\begin{lstlisting}
numView : ∀ b d o → NumView b d o
numView b       zero          o       = NoDigits b o
numView zero    (suc d)       o       = NullBase d o
numView (suc b) (suc zero)    zero    = AllZeros b
numView (suc b) (suc zero)    (suc o) = Proper b zero (suc o) _
numView (suc b) (suc (suc d)) o       = Proper b (suc d) o _
\end{lstlisting}

Together with \textit{with-abstractions}, we can, for example, define a function
to determine whether a numeral system is boring or not:

\begin{lstlisting}
boring : ∀ b d o → Bool
boring b d o with numView b d o
boring _ _ _ | NullBase d o         = false
boring _ _ _ | NoDigits b o         = false
boring _ _ _ | AllZeros b           = false
boring _ _ _ | Proper b d o proper  = true
\end{lstlisting}

As we can see, the function {\lstinline|numView|} does more than sorting indices
into different categories. It also reveals relevant infomation and properties
about these categories. For instance, if a system {\lstinline|Numeral b d o|}
is classified as \textit{Proper}, then we know that:

\begin{itemize}
    \item {\lstinline|b|} is greater than $ 0 $.
    \item {\lstinline|d|} is also greater than $ 0 $.
    \item {\lstinline|o|} can be any value as long as {\lstinline|d + o ≥ 2|};
        we name this requirement \textit{proper}.
\end{itemize}

\subsection{Views}

The sole purpose of {\lstinline|NumView|} is to sort out and expose some
interesting properties about its indices.
Such datatypes are called \textit{views}\cite{wadler1987views} as they present
different aspects of the very same object.
Functions like {\lstinline|numView|} are called \textit{view functions} or
\textit{eliminators}\cite{mcbride2004views} because they provide different ways
of eliminating a datatype.

Views are \textbf{reusable} as they free us from having to pattern match on the
same indices or data again and again. On the other hand, they can be customized
to our needs since they are just \textit{ordinary functions}.
We will define more views and use them extensively in the coming sections.

\section{Special Properties of Categories}

\paragraph{NoDigits}

Although systems with no digits have no pratical use, they are pretty easy to deal
with because all properties related to digits would hold unconditionally for
systems of {\lstinline|NoDigits|}.
This is proven by deploying \textit{the principle of explosion}.

\begin{lstlisting}
NoDigits-explode : ∀ {b o a} {Whatever : Set a}
    → (xs : Numeral b 0 o)
    → Whatever
NoDigits-explode (() ∙   )
NoDigits-explode (() ∷ xs)
\end{lstlisting}

\paragraph{NullBase}

The theorem below states that, evaluating a numeral of {\lstinline|NullBase|}
and evaluating its least significant digit would have the same result.

\begin{lstlisting}
toℕ-NullBase : ∀ {d o}
    → (x : Digit d)
    → (xs : Numeral 0 d o)
    → ⟦ x ∷ xs ⟧ ≡ Digit-toℕ x o
toℕ-NullBase {d} {o} x xs =
    begin
        Digit-toℕ x o + ⟦ xs ⟧ * 0
    ≡⟨ cong (λ w → Digit-toℕ x o + w) (*-right-zero ⟦ xs ⟧) ⟩
        Digit-toℕ x o + 0
    ≡⟨ +-right-identity (Digit-toℕ x o) ⟩
        Digit-toℕ x o
    ∎
\end{lstlisting}

\paragraph{AllZeros}

The theorem below states every numeral of {\lstinline|AllZeros|}
would evaluate to $ 0 $ regardless of the base.
To exploit the fact that there is only one digit in such numerals, we pattern
match on the digit to eliminate other possible cases.

\begin{lstlisting}
toℕ-AllZeros : ∀ {b} → (xs : Numeral b 1 0) → ⟦ xs ⟧ ≡ 0
toℕ-AllZeros     (z    ∙   ) = refl
toℕ-AllZeros     (s () ∙   )
toℕ-AllZeros {b} (z    ∷ xs)
    = cong (λ w → w * b) (toℕ-AllZeros xs)
toℕ-AllZeros     (s () ∷ xs)
\end{lstlisting}


\section{The Maximum Numeral}

A number is said to be the \textit{maximum} if there are no other numbers greater
than itself.

\begin{lstlisting}
Maximum : ∀ {b d o} → (xs : Numeral b d o) → Set
Maximum {b} {d} {o} xs = (ys : Numeral b d o) → ⟦ xs ⟧ ≥ ⟦ ys ⟧
\end{lstlisting}

If a numeral is the maximum
\footnote{More precisely, ``If a \text{value} of a numeral is the maximum ...''}
 then its least significant digit (LSD) must be the
greatest.

\begin{lstlisting}
Maximum⇒Greatest-LSD : ∀ {b} {d} {o}
    → (xs : Numeral b d o)
    → Maximum xs
    → Greatest (lsd xs)
\end{lstlisting}

\subsection{Properties of each Category}

\paragraph{NullBase}

\begin{center}
    \begin{tikzpicture}
        % a straight line segment
        \draw (0, 0) -- (10, 0);
        % the ticks and their labels
        \draw[xshift=0cm] (0pt,2pt) -- (0pt,-1pt) node[below,fill=white] {\the\numexpr0};
        % the thicker segment
        \draw[ultra thick] (1,0) -- (9,0);
        % the labels
        \node[fill=black,draw=black,circle,inner sep=2pt,label=above:{$o$}] at (1,0) {};
        \node[fill=black,draw=black,circle,inner sep=2pt,label=above:{$d+o$}] at (9,0) {};
        \node at (5, -0.5) {{\lstinline|ℕ|}};
    \end{tikzpicture}
\end{center}

It is obvious that systems of {\lstinline|NullBase|} have maxima.
If a numeral's LSD happens to be the greatest,
then the numeral must be the maximum.

\begin{lstlisting}
Maximum-NullBase-Greatest : ∀ {d} {o}
    → (xs : Numeral 0 (suc d) o)
    → Greatest (lsd xs)
    → Maximum xs
\end{lstlisting}

With this lemma, we can tell whether a numeral is the maximum by looking at its
LSD. In case that the LSD is not the greatest, we could say no by contraposition.

\begin{lstlisting}
    Maximum-NullBase : ∀ {d} {o}
        → (xs : Numeral 0 (suc d) o)
        → Dec (Maximum xs)
    Maximum-NullBase xs with Greatest? (lsd xs)
    Maximum-NullBase xs | yes greatest =
        yes (Maximum-NullBase-Greatest xs greatest)
    Maximum-NullBase | no ¬greatest =
        no (contraposition (Maximum⇒Greatest-LSD xs) ¬greatest)
\end{lstlisting}

\paragraph{AllZeros}

\begin{center}
    \begin{tikzpicture}
        % a straight line segment
        \draw (0, 0) -- (4, 0);
        % the ticks and their labels
        \draw[xshift=0cm] (0pt,2pt) -- (0pt,-1pt) node[below,fill=white] {\the\numexpr0};
        % the thicker segment
        \draw[ultra thick] (0,0) -- (0,0);
        % the labels
        \node[fill=white,draw=black,circle,inner sep=2pt,label=above:{$0$}] at (0,0) {};
        \node at (2, -0.5) {{\lstinline|ℕ|}};
    \end{tikzpicture}
\end{center}

\textit{All} numerals of systems of {\lstinline|AllZeros|} are maxima
since they are all mapped to $ 0 $.

\begin{lstlisting}
Maximum-AllZeros : ∀ {b}
    → (xs : Numeral b 1 0)
    → Maximum xs
Maximum-AllZeros xs ys = reflexive (
    begin
        ⟦ ys ⟧
    ≡⟨ toℕ-AllZeros ys ⟩
        zero
    ≡⟨ sym (toℕ-AllZeros xs) ⟩
        ⟦ xs ⟧
    ∎)
\end{lstlisting}

\paragraph{Proper}

On the contrary, there are no maxima in the systems of {\lstinline|Proper|}.
In fact, that is the reason why they are categorized as \textit{proper} in the
first place. This theorem is proven by contradicting two propositions:

\begin{itemize}
    \item Given {\lstinline|claim : Maximum xs|}, we claim that {\lstinline|xs|}
        is greater than or equal to {\lstinline|greatest-digit d ∷ xs|}, a numeral
        we composed by prefixing it with the greatest digit.
    \item On the other hand, We prove that {\lstinline|xs|} is less than
        {\lstinline|greatest-digit d ∷ xs|}.
\end{itemize}

\begin{lstlisting}
Maximum-Proper : ∀ {b d o}
    → (xs : Numeral (suc b) (suc d) o)
    → (proper : 2 ≤ suc (d + o))
    → ¬ (Maximum xs)
Maximum-Proper {b} {d} {o} xs proper claim = contradiction p ¬p
    where
        p : ⟦ xs ⟧ ≥ ⟦ greatest-digit d ∷ xs ⟧
        p = claim (greatest-digit d ∷ xs)
        ¬p : ⟦ xs ⟧ ≱ ⟦ greatest-digit d ∷ xs ⟧
        ¬p = <⇒≱ (
            start
                suc ⟦ xs ⟧
            ≈⟨ cong suc (sym (*-right-identity ⟦ xs ⟧)) ⟩
                suc (⟦ xs ⟧ * 1)
            ≤⟨ s≤s (n*-mono ⟦ xs ⟧ (s≤s z≤n)) ⟩
                suc (⟦ xs ⟧ * suc b)
            ≤⟨ +n-mono (⟦ xs ⟧ * suc b) (≤-pred proper) ⟩
                d + o + ⟦ xs ⟧ * suc b
            ≈⟨ cong
                (λ w → w + ⟦ xs ⟧ * suc b)
                (sym (greatest-digit-toℕ (Fin.fromℕ d)
                (greatest-digit-is-the-Greatest d)))
            ⟩
                ⟦ greatest-digit d ∷ xs ⟧
            □)
\end{lstlisting}


\subsection{Determine the Maximum}

We can \textit{decide} whether a numeral is the maximum by applying them to
lemmata of each categories.

\begin{lstlisting}
Maximum? : ∀ {b d o}
    → (xs : Numeral b d o)
    → Dec (Maximum xs)
Maximum? {b} {d} {o} xs with numView b d o
Maximum? xs | NullBase d o = Maximum-NullBase xs
Maximum? xs | NoDigits b o = no (NoDigits-explode xs)
Maximum? xs | AllZeros b   = yes (Maximum-AllZeros xs)
Maximum? xs | Proper b d o proper = no (Maximum-Proper xs proper)
\end{lstlisting}

% This theorem is proven by examine whether the LSD is the greatest.
% If it is the greatest, then we are done.
%
% \begin{lstlisting}
% Maximum⇒Greatest-LSD xs max with Greatest? (lsd xs)
% Maximum⇒Greatest-LSD xs max | yes greatest = greatest
% \end{lstlisting}
%
% If the LSD is not the greatest, we examine the index $ d $.
% If $ d $ is zero then we apply the principle of explosion to eliminate this case.
%
% \begin{lstlisting}
% Maximum⇒Greatest-LSD {b} {zero}      xs       max | no ¬greatest = NoDigits-explode xs
% \end{lstlisting}
%
%
%
% \begin{lstlisting}
% Maximum⇒Greatest-LSD {b} {suc d} {o} (x ∙)    max | no ¬greatest
%     = contradiction p ¬p
%     where
%         ys : Numeral b (suc d) o
%         ys = greatest-digit d ∙
%
%         p : Digit-toℕ x o ≥ ⟦ ys ⟧
%         p = max ys
%
%         ¬p : Digit-toℕ x o ≱ ⟦ ys ⟧
%         ¬p = <⇒≱ (
%             start
%                 suc (Digit-toℕ x o)
%             ≤⟨ +n-mono o (≤-pred (≤∧≢⇒< (bounded x) ¬greatest)) ⟩
%                 d + o
%             ≈⟨ sym (greatest-digit-toℕ (Fin.fromℕ d) (greatest-digit-is-the-Greatest d)) ⟩
%                 Digit-toℕ (greatest-digit d) o
%             ≈⟨ refl ⟩
%                 ⟦ ys ⟧
%             □)
% Maximum⇒Greatest-LSD {b} {suc d} {o} (x ∷ xs) max | no ¬greatest
%     = contradiction p ¬p
%     where
%         ys : Numeral b (suc d) o
%         ys = greatest-digit d ∷ xs
%
%         p : ⟦ x ∷ xs ⟧ ≥ ⟦ ys ⟧
%         p = max ys
%
%         ¬p : ⟦ x ∷ xs ⟧ ≱ ⟦ ys ⟧
%         ¬p = <⇒≱ (+n-mono (⟦ xs ⟧ * b) (
%             start
%                 suc (Digit-toℕ x o)
%             ≤⟨ +n-mono o (≤-pred (≤∧≢⇒< (bounded x) ¬greatest)) ⟩
%                 d + o
%             ≈⟨ sym (greatest-digit-toℕ (Fin.fromℕ d) (greatest-digit-is-the-Greatest d)) ⟩
%                 (Digit-toℕ (greatest-digit d) o)
%             □))
% \end{lstlisting}

\section{Systems with an Upper Bound}
\section{The Next Numeral}
\subsection{Incrementing a Numeral}
\subsection{Continuous Systems}


% \subsection{Maximum}
%
%
%
% \section{Conclusions}\label{conclusions}

\end{document}
