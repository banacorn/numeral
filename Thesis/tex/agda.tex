\documentclass[../thesis.tex]{subfiles}
\begin{document}

\chapter{A gental introduction to dependently typed programming in Agda}\label{agda}
% [draft]

There are already plenty of tutorials and introductions of Agda\cite{norell2009dependently}\cite{FLOLAC16DTP}\cite{brutal}.
We will nonetheless compile a simple and self-contained tutorial from the
materials cited above, covering the part (and only the part) we need in this work.

Some of the more advenced constructions (such as views and universes) used in
the following sections will be introduced along the way.

We assume that all readers have some basic understanding of Haskell, and those
who are familiar with Agda and dependently typed programming may skip this chapter.

\section{Some basics}
% [draft]

Agda is a \textit{dependently typed functional programming language} and also an
\textit{interactive proof assistant}. It can be both because it's based on
\textit{Martin-Löf type theory}\cite{martin1984intuitionistic}, hence the Curry-Howard
correspondence\cite{sorensen2006lectures}, which states that: "propositions are types"
and "proofs are programs". In other words, proving theorems and writing programs
are essentially the same. In Agda we are free to interchange between these two
interpretations. The current version (Agda2) is a completely rewrite by Ulf Norell
during his PhD at Chalmers University of Technology.

We say that Agda is interactive because proving
theorems involves a lot of conversations between the programmer and the type checker.
And it is often difficult, if not impossible, to develop and prove a theorom at one stroke.
Just like programming, the process is incremental.
So Agda allows us to leave some "holes" in a program, refine them gradually, and
complete the proofs "hole by hole".

Take this half-finished function definition for instance, we could leave out the
right-hand side.

\begin{lstlisting}
is-zero : Int → Bool
is-zero x = ?
\end{lstlisting}

In practice, we would ask, for example, "what's the type of the goal?",
 "what's the context of this case?", etc. And Agda would reply us with:

\begin{lstlisting}
GOAL : Bool
x : Int
\end{lstlisting}

Then we may ask Agda to pattern match on {\lstinline|x|} and rewrite the program for us:

\begin{lstlisting}
is-zero : Int → Bool
is-zero zero    = ?
is-zero (suc x) = ?
\end{lstlisting}

We could fulfill these goals by giving an answer, we may even ask Agda to solve
the problem for us, if it is not too difficult.

\begin{lstlisting}
is-zero : Int → Bool
is-zero zero    = true
is-zero (suc x) = false
\end{lstlisting}

After all of the goals have been accomplished and type-checked, we consider the
program to be finished. Often, there's not much point in running a Agda program,
because it's mostly about static constructions that is checked in compile-time.
This is basically what pragramming and proving things looks like in Agda.

\section{Simply typed programming in Agda}

Since Agda was heavily influenced by Haskell, simply typed programming in Agda
is similar to that in Haskell.

\paragraph{Datatypes}
% [draft]

Unlike in other programming languages, there are no "built-in"
datatypes such as \textit{Int}, \textit{String}, or \textit{Bool}.
The reason is that they can all be created out of thin air, so why bother?

Datatypes are introduced with {\lstinline|data|} declarations.
Here is a classical example, the type of booleans.

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

The name of the datatype ({\lstinline|Bool|}) and its constructors
({\lstinline|true|} and {\lstinline|false|}) are brought into scope in this declaration.
This notation also allow us to explicitly specify the types of these newly introduced entities.

\begin{enumerate}
    \item {\lstinline|Bool|} has the type of {\lstinline|Set|}\footnote{{\lstinline|Set|} is the type of small types, and {\lstinline|Set₁|} is the type
of {\lstinline|Set|}, and so on. They form a hierarchy of types.}
    \item {\lstinline|true|} has the type of {\lstinline|Bool|}
    \item {\lstinline|false|} has the type of {\lstinline|Bool|}
\end{enumerate}

\paragraph{Pattern matching}
% [draft]
Similar to Haskell, datatypes are eliminated with pattern matching.

Here's a function that pattern matches on {\lstinline|Bool|}.

\begin{lstlisting}
not : Bool → Bool
not true  = false
not false = true
\end{lstlisting}

Agda is a \textit{total} language, that means partial functions are not valid constructions.
Functions are guarantee to terminate and will not crash on all possible inputs.
The following example won't be accecpted by the type checker, because the case
{\lstinline|false|} is missing.

\begin{lstlisting}
not : Bool → Bool
not true  = false
\end{lstlisting}

In practice, Agda would automatically expand all of the cases for us on demand.

\paragraph{Inductive datatype} Let's move on to a more interesting datatype with
inductive definition. Here's the type of natural numbers.
% [draft]
\begin{lstlisting}
data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ
\end{lstlisting}

The decimal number "4" is represented as {\lstinline|suc (suc (suc (suc zero)))|}.
Agda also accepts arabic literals if the datatype {\lstinline|ℕ|} complies with
certain language pragma.

Addition on {\lstinline|ℕ|} can be defined as a recursive function.

\begin{lstlisting}
_+_ : ℕ → ℕ → ℕ
zero  + y = y
suc x + y = suc (x + y)
\end{lstlisting}

We define {\lstinline|_+_|} by pattern matching on the first argument, which results
in two cases: the base case, and the inductive step. We are allowed to make
recursive calls, as long as the type checker is convinced that the function
would terminate.

The underlines surrounding {\lstinline|_+_|} act as placeholders for arguments, making
it an infix function in this instance.

\paragraph{Dependent functions and type arguments}
% [reviewed: 1]
Up till now everything looks much the same as in Haskell, but a problem arises as
we move on to defining something that needs more power of abstraction. Take identity
functions for example:

\begin{lstlisting}
id-Bool : Bool → Bool
id-Bool x = x

id-ℕ : ℕ → ℕ
id-ℕ x = x
\end{lstlisting}

In order to define a more general identity function, those concrete types have
to be abstracted away. That is, we need parametric polymorphism, and this is
where dependent types come into play.

A dependent type is a type whose definition may depend on a value. A dependent
function is a function whose result type may depend on the value of an argument.

In Agda, function types are denoted as:

\begin{lstlisting}
A → B
\end{lstlisting}

Where {\lstinline|A|} is the type of domain and {\lstinline|B|} is the type of
codomain. To let {\lstinline|B|} depends on the value of {\lstinline|A|}, the
value has to \textit{named}, in Agda we write:

\begin{lstlisting}
(x : A) → B x
\end{lstlisting}

The value of {\lstinline|A|} is named {\lstinline|x|} and then fed to {\lstinline|B|}.
As a matter of fact, {\lstinline|A → B|} is just a syntax sugar for {\lstinline|(_ : A) → B|}
with the name of the value being irrelevant. The underline {\lstinline|_|} here
means "I don't bother naming it".

Back to our identity function, if {\lstinline|A|} happens to be {\lstinline|Set|},
the type of all small types, and the result type happens to be solely {\lstinline|x|}:

\begin{lstlisting}
(x : Set) → x
\end{lstlisting}

Voila, we have polymorphism, and thus the identity function can now be defined as:

\begin{lstlisting}
id : (A : Set) → A → A
id A x = x
\end{lstlisting}

{\lstinline|id|} now takes an extra argument, the type of the second arguement.
{\lstinline|id Bool true|} evaluates to {\lstinline|true|}

\paragraph{Implicit arguments}
% [reviewed: 1]

We have implemented an identity function and seen how polymorphism can be modeled
with dependent types. However, the additional argument that the identity function
takes is rather unnecessary, since its value can always be determined by looking
at the type of the second argument.

Fortunately, Agda supports \textit{implicit arguments}, a syntax sugar that could
save us the trouble of having to spell them out. Implicit arguments are enclosed
in curly brackets in the type expression. We are free to dispense with these arguments
when their values are irrelevant to the definition.

\begin{lstlisting}
id : {A : Set} → A → A
id x = x
\end{lstlisting}

Or when the type checker can figure them out on function application.

\begin{lstlisting}
val : Bool
val = id true
\end{lstlisting}

Any arguments can be made implicit, but it does not imply that values of
implicit arguments can always be inferred or derived from context. We can always
make them implicit arguments explicit on application:

\begin{lstlisting}
val : Bool
val = id {Bool} true
\end{lstlisting}

Or when they are relevant to the definition:

\begin{lstlisting}
silly-not : {_ : Bool} → Bool
silly-not {true}  = false
silly-not {false} = true
\end{lstlisting}

\paragraph{More syntax sugars}
% [draft]
We could skip arrows between arguments in parentheses or braces:

\begin{lstlisting}
id : {A : Set} (a : A) → A
id {A} x = x
\end{lstlisting}

And there is a shorthand for merging names of arguments of the same type, implicit or not:

\begin{lstlisting}
const : {A B : Set} → A → B → A
const a _ = a
\end{lstlisting}

Sometimes when the type of some value can be inferred, we could either replace
the type with an underscore, say {\lstinline|(A : _)|}, or we could write it as
{\lstinline|∀ A|}. For the implicit counterpart, {\lstinline|{A : _}|} can be
written as {\lstinline|∀ {A}|}.

\paragraph{Parameterized Datatypes}
% [draft]

Just as functions can be polymorphic, datatypes can be parameterized by other
types, too. The datatype of lists is defined as follows:

\begin{lstlisting}
data List (A : Set) : Set where
    []  : List A
    _∷_ : A → List A → List A
\end{lstlisting}

The scope of the parameters extends over the entire declaration, so they can
appear in the constructors.
Here are the types of the datatype and its constructors.

\begin{lstlisting}
infixr 5 _∷_

[] : {A : Set} → List A
_∷_ : {A : Set} → A → List A → List A
List : Set → Set
\end{lstlisting}

Where {\lstinline|A|} can be anything, even {\lstinline|List (List (List Bool))|},
as long as it is of type {\lstinline|Set|}. {\lstinline|infixr|} specifies the
precedence of the operator {\lstinline|_∷_|}.

\paragraph{Indexed Datatypes}
% [draft]

% Indexed datatypes, or inductive families, allow us to not only

{\lstinline|Vec|} is a datatype that is similar to {\lstinline|List|}, but more
powerful, in that it can tell you not only the type of its element, but also its
length.

\begin{lstlisting}
data Vec (A : Set) : ℕ → Set where
    []  : Vec A zero
    _∷_ : {n : ℕ} → A → Vec A n → Vec A (suc n)
\end{lstlisting}

{\lstinline|Vec A n|} is a vector of values of type {\lstinline|A|} and
has the length of {\lstinline|n|}. Here are some of its inhabitants:

\begin{lstlisting}
nil : Vec Bool zero
nil = []

vec : Vec Bool (suc (suc zero))
vec = true ∷ false ∷ []
\end{lstlisting}

We say that {\lstinline|Vec|} is \textit{parameterized} by a type of {\lstinline|Set|}
and is \textit{indexed} by values of {\lstinline|ℕ|}.
And we distinct indices from parameters. However, it is not obvious how they are
different by looking at the declaration.

Parameters are \textit{parametric}, in the sense that, they have no effect on the "shape" of a datatype.
The choice of parameters only effects which kind of values are placed there.
Pattern matching on parameters does not reveal any insights about their whereabouts.
Because they are \textit{uniform} across all constructors, one can always replace
the value of a parameter with another one of the same type.

On the other hand, indices may affect which inhabitants are allowed in the
datatype. Different constructors may have different indices. In that case, pattern
matching on indices may yield relevant information about their constructors.

For example, if there's term whose type is {\lstinline|Vec Bool zero|}, then
we are certain that the constructor must be {\lstinline|[]|}, and if the type
 is {\lstinline|Vec Bool (suc n)|} for some {\lstinline|n|}, then the constructor
must be {\lstinline|_∷_|}.

We could for instance define a {\lstinline|head|} function that cannot crash.

\begin{lstlisting}
head : ∀ {A n} → Vec A (suc n) → A
head (x ∷ xs) = x
\end{lstlisting}

As a side note, parameters can be thought as a degenerate case of indices whose
distribution of values are uniform across all constructors.

\paragraph{With abstraction}
% [draft]

Say, we want to define {\lstinline|filter|} on {\lstinline|List|}:

\begin{lstlisting}
filter : ∀ {A} → (A → Bool) → List A → List A
filter p [] = []
filter p (x ∷ xs) = ?
\end{lstlisting}

We are stuck here, because the result of {\lstinline|p x|} is only available in
runtime. Fortunately, with abstraction allows us to pattern match on the result
of an intermediate computation by adding the result as an extra argument on the
left-hand side:

\begin{lstlisting}
filter : ∀ {A} → (A → Bool) → List A → List A
filter p [] = []
filter p (x ∷ xs) with f x
filter p (x ∷ xs) | true  = x ∷ filter p xs
filter p (x ∷ xs) | false = filter p xs
\end{lstlisting}

\paragraph{Absurd patterns}
% [draft]

The \textit{unit type}, or \textit{top}, is a datatype inhabited by
exactly one value, denoted {\lstinline|tt|}.

\begin{lstlisting}
data ⊤ : Set where
    tt : ⊤
\end{lstlisting}

The \textit{empty type}, or \textit{bottom}, on the other hand, is a datatype
that is inhabited by nothing at all.

\begin{lstlisting}
data ⊥ : Set where
\end{lstlisting}

These types seem useless, and without constructors, it is impossible to
construct an instance of {\lstinline|⊥|}. What is an type that cannot be
constructed good for?

Say, we want to define a safe {\lstinline|head|} on {\lstinline|List|} that
does not crash on any inputs. Naturally, in a language like Haskell,
we would come up with a predicate like this to filter out empty lists
{\lstinline|[]|} before passing them to {\lstinline|head|}.

\begin{lstlisting}
non-empty : ∀ {A} → List A → Bool
non-empty []       = false
non-empty (x ∷ xs) = true
\end{lstlisting}

The predicate only works at runtime. It is impossible for the type
checker to determine whether the input is empty or not at compile time.

However, things are quite different quite in Agda. With \textit{top} and \textit{bottom},
we could do some tricks on the predicate, making it returns a \textit{Set}, rather
than a \textit{Bool}!

\begin{lstlisting}
non-empty : ∀ {A} → List A → Set
non-empty []       = ⊥
non-empty (x ∷ xs) = ⊤
\end{lstlisting}

Notice that now this predicate is returning a type. So we can use it in the type
expression. {\lstinline|head|} can thus be defined as:

\begin{lstlisting}
head : ∀ {A} → (xs : List A) → non-empty xs → A
head []       proof = ?
head (x ∷ xs) proof = x
\end{lstlisting}

In the {\lstinline|(x ∷ xs)|} case, the arguement {\lstinline|proof|} would
have type {\lstinline|⊤|}, and the right-hand side is simply {\lstinline|x|};
in the {\lstinline|[]|} case, the arguement {\lstinline|proof|} would
have type {\lstinline|⊥|}, but what should be returned at the right-hand side?

It turns out that, the right-hand side of the {\lstinline|[]|} case would be the
least thing to worry about, because it is completely impossible to have such a case.
Recall that {\lstinline|⊥|} has no inhabitants, so if a case has an argument of
that type, it is too good to be true.

Type inhabitance is in general an undecidable problem.
However, when pattern matching on a type that is obviously empty (such as {\lstinline|⊥|}),
Agda allows us to drop the right-hand side and eliminate the arguement with {\lstinline|()|}.

\begin{lstlisting}
head : ∀ {A} → (xs : List A) → non-empty xs → A
head []       ()
head (x ∷ xs) proof = x
\end{lstlisting}

Whenever an empty list is applied to {\lstinline|head|},
the resulting function would have type {\lstinline|head [] : ⊥ → A|},
which is impossible to fulfill unless one could find a value of type {\lstinline|⊥|}.

\paragraph{Propositions as types, proofs as programs}

The previous paragraphs are mostly about the \textit{programming}
aspect of the language, but there is another aspect to it.
Recall the Curry–Howard correspondence, propositions are types and proofs are
programs. A proof exists for a proposition the way that a value inhabits a type.

So {\lstinline|non-empty xs|} is a type, but it can also be thought of as a
proposition stating that {\lstinline|xs|} is not empty.
When {\lstinline|non-empty xs|} evaluates to {\lstinline|⊥|}, no value inhabits
{\lstinline|⊥|}, that means no proof exists for the proposition {\lstinline|⊥|};
when {\lstinline|non-empty xs|} evaluates to {\lstinline|⊥|}, {\lstinline|tt|}
inhabits {\lstinline|⊥|}, a trivial proof exists for the proposition {\lstinline|⊤|}.

In intuitionistic logic, a proposition is considered to be "true" when it is
inhabited by a proof, and considered to be "false" when there exists no proof.
Contrary to classical logic, where propositions evaluates to truth values.
We can see that {\lstinline|⊤|} and {\lstinline|⊥|} correspondes to \textit{true}
and \textit{false} in this sense.

Negation can be defined as a function from a proposition to {\lstinline|⊥|}.

\begin{lstlisting}
¬ : Set → Set
¬ P = P → ⊥
\end{lstlisting}

We could exploit {\lstinline|⊥|} further to deploy the principle of explosion
of intuitionistic logic, which states that: "from falsehood, anything (follows)"
(Latin: \textit{ex falso (sequitur) quodlibet}).

\begin{lstlisting}
⊥-elim : ∀ {Whatever : Set} → ⊥ → Whatever
⊥-elim ()
\end{lstlisting}


\paragraph{Decidable propositions}

A proposition is decidable when it can be proved \textit{or} disapproved.
\footnote{The connective \textit{or} here is not a disjunction in the classical sense.
Either way, a proof or a disproval has to be given.}

\begin{lstlisting}
data Dec (P : Set) : Set where
    yes :   P → Dec P
    no  : ¬ P → Dec P
\end{lstlisting}

{\lstinline|Dec|} is very similar to its two-valued cousin {\lstinline|Bool|},
but way more powerful, because it also explains (with a proof) why a proposition
holds or why it does not.

Suppose we want to know if a natural is even or odd. We know that {\lstinline|zero|}
is an even number, and if a number is even then its successor's successor is also even.

\begin{lstlisting}
    data Even : ℕ → Set where
        base : Even zero
        step : ∀ {n} → Even n → Even (suc (suc n))
\end{lstlisting}

We also need the opposite of {\lstinline|step|} as a lemma.

\begin{lstlisting}
    2-steps-back : ∀ {n} → ¬ (Even n) → ¬ (Even (suc (suc n)))
    2-steps-back ¬p q = ?
\end{lstlisting}

{\lstinline|2-steps-back|} takes two argument instead of one because the return
type {\lstinline|¬ (Even (suc (suc n)))|} is actually a synonym of
{\lstinline|Even (suc (suc n)) → ⊥|}. Pattern matching on the second argument
of type {\lstinline|Even (suc (suc n))|} further reveals that it could only be
constructed by {\lstinline|step|}.  By contradicting {\lstinline|¬p : ¬ (Even n)|}
and {\lstinline|p : Even n|}, we complete the proof of this lemma.

\begin{lstlisting}
    contradiction : ∀ {P Whatever : Set} → P → ¬ P → Whatever
    contradiction p ¬p = ⊥-elim (¬p p)

    two-steps-back : ∀ {n} → ¬ (Even n) → ¬ (Even (suc (suc n)))
    two-steps-back ¬p (step p) = contradiction p ¬p
\end{lstlisting}

Finally, {\lstinline|Even?|} determines a number is even by induction on its
predecessor's predecessor. {\lstinline|step|} and {\lstinline|two-steps-back|}
can be viewed as functions that transforms proofs.

\begin{lstlisting}
    Even? : (n : ℕ) → Dec (Even n)
    Even? zero          = yes base
    Even? (suc zero)    = no (λ ())
    Even? (suc (suc n)) with Even? n
    Even? (suc (suc n)) | yes p = yes (step p)
    Even? (suc (suc n)) | no ¬p = no  (two-steps-back ¬p)
\end{lstlisting}

The syntax of {\lstinline|λ ()|} looks weird, as the result of contracting
an argument of type {\lstinline|⊥|} of a lambda expression {\lstinline|λ x → ?|}.
It is a convention to suffix a decidable function's name with {\lstinline|?|}.

\paragraph{Propositional equality}

Saying that two things are "equal" is a notoriously intricate topic in type theory.
There are many different notions of equality
\cite{equality}. We will not go
into each kind of equalities in depth but only skim through those exist in Agda.

\textit{Definitional equality}, or \textit{intensional equality} is simply a
synonym, a relation between linguistic expressions. It is a primitive judgement
of the system, stating that two things are the same to the type checker
\textbf{by definition}.

\textit{Computational equality} is a slightly more powerful notion.
Two programs are consider equal if they compute (beta-reduce) to the same value.
For example, {\lstinline|1 + 1|} and {\lstinline|2|} are equal in Agda in this notion.

But we cannot say that {\lstinline|a + b|} and {\lstinline|b + a|}
are equal with definitional or computational equality, because this kind of equality
is \textit{extensional}. However, it could be expressed as a \textit{proposition}
with \textit{identity types}.

\begin{lstlisting}
data _≡_ {A : Set} (x : A) : A → Set where
    refl : x ≡ x
\end{lstlisting}

For all {\lstinline|a b : A|}, if {\lstinline|a|} and {\lstinline|b|} are
\textit{computationally equal}, that is, both computes to the same value,
then {\lstinline|refl|} is a proof of {\lstinline|a ≡ b|},
the \textit{propositional equality} of {\lstinline|a|} and {\lstinline|b|}.

{\lstinline|_≡_|} is an equivalence relation. It means that {\lstinline|_≡_|}
is \textit{reflexive} (by definition), \textit{symmetric} and \textit{transitive}.

\begin{lstlisting}
sym : {A : Set} {a b : A} → a ≡ b → b ≡ a
sym refl = refl

trans : {A : Set} {a b c : A} → a ≡ b → b ≡ c → a ≡ c
trans refl refl = refl
\end{lstlisting}

{\lstinline|_≡_|} is congruent, meaning that we could \textbf{substitute equals for equals}.

\begin{lstlisting}
cong : {A B : Set} {a b : A} → (f : A → B) → a ≡ b → f a ≡ f b
cong f refl = refl
\end{lstlisting}

Although these {\lstinline|refl|}s look all the same at term level, they
are proofs of different propositional equalities.

\paragraph{Dotted patterns}

Consider an alternative version of {\lstinline|sym|} on {\lstinline|ℕ|}.

\begin{lstlisting}
sym' : (a b : ℕ) → a ≡ b → b ≡ a
sym' a b eq = ?
\end{lstlisting}

Where {\lstinline|eq|} has type {\lstinline|a ≡ b|}.
If we pattern match on {\lstinline|eq|} then Agda would rewrite {\lstinline|b|}
as {\lstinline|.a|} and the goal type becomes {\lstinline|a ≡ a|}.

\begin{lstlisting}
sym' : (a .a : ℕ) → a ≡ a → a ≡ a
sym' a .a eq = ?
\end{lstlisting}

What happened under the hood is that {\lstinline|a|} and {\lstinline|b|} are
\textit{unified} as the same thing. The second argument is dotted to signify that
it is \textit{constrained} by the first argument {\lstinline|a|}. {\lstinline|a|}
becomes the only argument available for further binding or pattern matching.

\paragraph{Standard library}

It would be inconvenient if we have to construct everything we need from scratch.
Luckily, the community has maintained a standard library that comes with many useful
and common constructions.

The standard library is not "chartered" by the compiler or the type checker,
there's simply nothing special about it. We may as well as roll our own library.
\footnote{Some primitives that require special treatments, such as IO, are take cared with
language pragmas exposed by Agda.}


\end{document}
