\providecommand{\main}{..}
\documentclass[\main/thesis.tex]{subfiles}
\begin{document}
\chapter{Translating Propositions and Proofs}\label{translation}

In this chapter, we demonstrate how to translate propositions and proofs between
\lstinline|ℕ| and a subset of \lstinline|Numeral|.

People have put a lot of effort into proving theorems and properties on
\lstinline|ℕ|.
However, all these results are unusable for \lstinline|Numeral|,
although \lstinline|ℕ| and \lstinline|Numeral| both have a similar structure and
share the same purpose of representing natural numbers.
We cannot simply apply a property of \lstinline|ℕ|, say,
the commutative property of addition, on instances of \lstinline|Numeral|.

The reason behind this misery comes from the difference between so-called
\textbf{object languages} and \textbf{metalanguages}.
The relation and similarities between \lstinline|ℕ| and \lstinline|Numeral|
we have observed are expressed using some \textit{metalanguage} in our mind;
while the propositions and proofs we want to reuse are formalized with Agda,
the \textit{object language} we have been dwelling on.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
        \begin{tikzpicture}

            % the frame
            \path[clip] (0, -3) rectangle (12, 3);

            % UR
            \draw[ultra thick] (1, 1) rectangle (11,3);
            \node at (6, 2) {underlying representation of propositions};

            % SR
            \draw[ultra thick] (1, -1) rectangle (5,-3);
            \node[text width=5cm, scale=0.8, align=center] at (3, -2)
                {surface representation of propositions of \lstinline|ℕ|};

            % SR
            \draw[ultra thick] (7, -1) rectangle (11,-3);
            \node[text width=5cm, scale=0.8, align=center] at (9, -2)
                {surface representation of propositions of \lstinline|Numeral|};


            % the border line
            \node[right] at (0, 0.5) {in our mind};
            \draw[dotted, ultra thick] (0,0) -- (12,0);
            \node[right] at (0, -0.5) {in Agda};

            \draw[->, ultra thick] (3, -0.9) -- (3, 0.9);
            \draw[->, ultra thick] (9, 0.9) -- (9, -0.9);

        \end{tikzpicture}
    \end{adjustbox}
\end{center}

When we are proving propositions of \lstinline|Numeral| base on the ones that
already existed on \lstinline|ℕ|, we are actually translating propositions via
some metalanguage in our mind.

To free ourselves from these brainworks, we can encode the
underlying representation of propositions in Agda,
so that we can manipulate and translate them with the
help of constructions such as functions available from the object language.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
        \begin{tikzpicture}

            % the frame
            \path[clip] (0, -4) rectangle (12, 5);

            % UR
            \draw[ultra thick] (1, 1) rectangle (11,3);
            \node at (6, 2) {underlying representation of propositions};

            % SR
            \draw[ultra thick] (1, -1) rectangle (5,-3);
            \node[text width=5cm, scale=0.8, align=center] at (3, -2)
                {surface representation of propositions of \lstinline|ℕ|};

            % SR
            \draw[ultra thick] (7, -1) rectangle (11,-3);
            \node[text width=5cm, scale=0.8, align=center] at (9, -2)
                {surface representation of propositions of \lstinline|Numeral|};

            % the border line
            \draw[dotted, ultra thick] (0,4) -- (12,4);
            \node[right] at (0, 3.5) {in Agda};

            \draw[->, ultra thick] (3, -0.9) -- (3, 0.9);
            \draw[->, ultra thick] (9, 0.9) -- (9, -0.9);

        \end{tikzpicture}
    \end{adjustbox}
\end{center}

The underlying representation of propositions can be encoded in Agda
using a generic programming technique called \textit{universe construction}
\cite{norell2009dependently}.

\section{Universe Constructions}

A universe is a set of types;
a universe construction \scmsubst{is consists}{consists} of:

\begin{itemize}
    \item A universe
    \item A datatype of ``codes''
    \item A decoding function that maps ``codes'' to the types in the universe
\end{itemize}

\subsection{A Simple Universe}

There is an universe construction we are familiar with: the universe
of \lstinline|⊤| and \lstinline|⊥|.

\subsubsection{Types}

\begin{lstlisting}
data ⊤ : Set where
    tt : ⊤
data ⊥ : Set where
\end{lstlisting}

\subsubsection{Codes}

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

\subsubsection{Decoder}

\begin{lstlisting}
isTrue : Bool → Set
isTrue true  = ⊤
isTrue false = ⊥
\end{lstlisting}

As we have shown, we can use this universe to implement, for instance, a safe
\lstinline|head| function that cannot be type-checked on empty inputs.

\begin{lstlisting}
null : ∀ {A} → (xs : List A) → Bool
null []       = true
null (x ∷ xs) = false

not : Bool → Bool
not true  = false
not false = true

head : ∀ {A} → (xs : List A) → isTrue (not (null xs)) → A
head []       ()
head (x ∷ xs) proof = x
\end{lstlisting}

We can generate \scmsubst{the codes}{code} from \lstinline|null|,
manipulate the code with \lstinline|not|,
and finally, realize them to \lstinline|⊤| or \lstinline|⊥| with \lstinline|isTrue|.

\subsection{Summary}

Below is a table that sums up the correspondences of universe construction.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{ l l l l l }
    universe & corresponds to & surface representation & corresponds to & semantics \\
    codes & corresponds to & underlying representation & corresponds to & syntax \\
    decoder & corresponds to & realization & corresponds to & interpretation \\
    \end{tabular}
    \end{adjustbox}
\end{center}

\section{First-order Logic on the Representations of Natural Numbers}

% \paragraph{Remark}
% What we meant by ``proposition'' in this chapter has a broader sense than that in
% \textit{propositional logic}. It also includes ``predicates'' that have
% quantifiers ranging over. These two words will be used interchangeably.

To translate propositions (and predicates) from \lstinline|ℕ| to
\lstinline|Numeral| (or vice versa),
we need an underlying syntax for expressing these propositions.
For that matter, we will demonstrate how to build a minimalistic first-order
logic with universe constructions.

\subsection{Syntax}
Syntax and semantics are two key parts of first-order logic.

What we called ``proposition'' are actually \textit{predicates} that have
quantifiers ranging over. Predicates are composed of smaller predicates or
basic units that we called \textit{terms}.

There are many kinds of predicates we can make on natural numbers.
However, we will target only at the predicates that can be expressed in both
\lstinline|ℕ| and \lstinline|Numeral|.

Therefore, the set of terms will be inductively defined by only two rules:
\begin{itemize}
    \item \textbf{Variable}: Any variable of the \textit{domain of discourse} (\lstinline|ℕ| or
        \lstinline|Numeral|) is a term.
    \item \textbf{Addition}: Any two terms put together with the addition function of that
        domain is also a term.
\end{itemize}

We will only have terms that \scmsubst{looks}{look} like this:

\begin{lstlisting}
x + (y + z)
\end{lstlisting}

The set of predicates is inductively defined by three rules:

\begin{itemize}
    \item \textbf{Equality}: If $\phi$ and $\psi$ are two terms, then
        $ \phi \equiv \psi $ is a predicate.
    \item \textbf{Implication}: If $\phi$ and $\psi$ are two predicates, then
        $ \phi \implies \psi $ is also a predicate.
    \item \textbf{Universal Quantification}: If $\phi$ is predicate that may
        contain $ 1 + n $ free variables, then $ \forall \phi $ is a predicate that
        may only contain $ n $ free variables.
\end{itemize}

With these connectives and quantifiers, we can make predicates such as:

\begin{lstlisting}
(x + y) + z ≈ x + (y + z)
∀ x . x ≈ y → y ≈ y
\end{lstlisting}

\subsection{Codes for Syntax}

To describe the syntax, we have two datatypes for codes,
one for \textit{terms} and \scmsubst{the another}{another} for \textit{predicates}.

\subsubsection{Terms}

\begin{lstlisting}
data Term : ℕ → Set where
    var : ∀ {n} → Fin n → Term n
    add : ∀ {n} → Term n → Term n → Term n
\end{lstlisting}

The code for terms is indexed by a \lstinline|ℕ| which denotes the number
of \textit{free variables} that may occur in a predicate.
The \lstinline|Fin n| that \lstinline|var| takes designates its binder.
\subsubsection{Predicates}

\begin{lstlisting}
data Predicate : ℕ → Set where
    _≋P_ : ∀ {n} → (t₁ : Term n) → (t₂ : Term n) → Predicate n
    _→P_ : ∀ {n} → (p₁ : Predicate n) → (p₂ : Predicate n)
         → Predicate n
    ∀P   : ∀ {n} → (p : Predicate (suc n)) → Predicate n
\end{lstlisting}

The code for predicates is also indexed by the number of \textit{free variables}.
\lstinline|_≋P_| and \lstinline|_→P_| correspond to equality and implication
connectives respectively.
It is worth noting that \lstinline|∀P| returns a predicate with a smaller index
because one of the free variable of the given predicate has been bound.

\subsubsection{Examples}

The transitivity of identity of the equality connective can be described
as follows:

\begin{lstlisting}
≋-trans : Predicate zero
≋-trans = let   x = var (# 0)
                y = var (# 1)
                z = var (# 2)
    in ∀P (∀P (∀P (((x ≋P y) →P (y ≋P z)) →P (x ≋P z))))
\end{lstlisting}

\subsection{Semantics}

The semantics determine meanings behind these propositions, and by meanings
we mean the selection of types of the universe we are constructing.

\subsubsection{Signatures}

A syntax can be interpreted as many different semantics.
Each semantics has its own choice of interpreting a piece of syntax,
we call these choices a \textit{signature}.
Therefore each semantics has its own signature.

The datatype of signature can defined as follows:

\begin{lstlisting}
record Signature : Set₁ where
    constructor sig
    field
        carrier : Set
        _⊕_ : carrier → carrier → carrier
        _≈_ : carrier → carrier → Set
\end{lstlisting}

Different semantics have different signatures.

\begin{lstlisting}
ℕ-sig : Signature
ℕ-sig = sig ℕ _+_ _≡_

Numeral-sig : (b d : ℕ) → True (Continuous? b d 0) → Signature
Numeral-sig b d cont = sig (Numeral b d 0) (_+_ {cont = cont}) _≋_
\end{lstlisting}

Note that \lstinline|ℕ-sig| and \lstinline|Numeral-sig| are equipped with
different equality connectives.
The one equipped by \lstinline|Numeral-sig| is defined as follows:

\begin{lstlisting}
_≋_ : ∀ {b d o}
    → (xs ys : Numeral b d o)
    → Set
xs ≋ ys = ⟦ xs ⟧ ≡ ⟦ ys ⟧
\end{lstlisting}

We need a different type for equality because systems of \lstinline|Numeral|
may be redundant, that is, two numerals may look different to the identity
type \lstinline|_≡_| even if they both evaluates to the same number.
\scm{By ``a different type for equality'' do you mean the type of
\lstinline|_≋_|? From what is it different? Might be worth to be clear here.}

Also, the index $ o $ of \lstinline|Numeral| is fixed to $ 0 $.
We will explain why the domain of discourse is limited that way in the
later section.

\subsubsection{Meaning of Variables}

Terms and predicates can have free variables, but variables are given
meanings only when they are substituted.

\begin{lstlisting}
var : ∀ {n} → (i : Fin n) → Term n
\end{lstlisting}

\lstinline|var| have to pick a number $ i $ of \lstinline|Fin n| as its name,
because values of all variables are stored in a \lstinline|Vec n| (a list of length $ n $.)
Upon substitution, we pick the $ i $th element of the list as its value.

\subsubsection{Interpreting Terms}

The interpreter of the syntax for terms is defined as follows:

\begin{lstlisting}
⟦_⟧T : ∀ {n}
    → Term n
    → (sig : Signature)
    → Vec (carrier sig) n
    → carrier sig
⟦ var i ⟧T _ env = lookup i env
⟦ add term₁ term₂ ⟧T sig env
    = ⟦ term₁ ⟧T sig env ⊕ ⟦ term₂ ⟧T sig env
\end{lstlisting}

\lstinline|carrier sig| evaluates to the carrier of the signature, the domain
of discours. For example, \lstinline|carrier ℕ-sig| evaluates to \lstinline|ℕ|.
In addition to the term, \lstinline|⟦_⟧T| also takes a signature, meanings of
all variables, and returns an element of the carrier.

In the case of \lstinline|var|,
\lstinline|lookup| retrieves the $i$th value for the variable from \lstinline|env|.
This is where the variable substitution happens.

In the case of \lstinline|add|,
the semantics of both terms are interpreted recursively,
and then computed with \lstinline|_⊕_|,
the addition function supplied by the signature.
\scm{Is \lstinline|sig| opened (so that we have access to \lstinline|_⊕_|)?}

\subsubsection{Interpreting Predicates}

The interpreter of the syntax for predicates is defined as follows:

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
⟦_⟧P : ∀ {n}
    → Predicate n
    → (sig : Signature)
    → Env (carrier sig) n
    → Set
⟦ t₁ ≋P t₂ ⟧P sig env       = ⟦ t₁ ⟧T sig env ≈ ⟦ t₂ ⟧T sig env
⟦ p →P q   ⟧P signature env = ⟦ p ⟧P signature env → ⟦ q ⟧P signature env
⟦ ∀P pred  ⟧P signature env = ∀ x → ⟦ pred ⟧P signature (x ∷ env)
\end{lstlisting}

Similar to that of interpreting terms, except that \lstinline|⟦_⟧P| returns a
\textit{type}.

In the case of \lstinline|_≋P_|,
the semantics of both terms are interpreted using \lstinline|⟦_⟧T|,
\lstinline|_≈_| is the equality connective supplied by the signature.

In the case of \lstinline|_→P_|,
the semantics of both predicates are interpreted recursively
and connected with the native implication \lstinline|_→_| provided by Agda.

Finally, when it comes to \lstinline|∀P|,
a new variable is introduced and then added to the list of meanings of variables
for the interpreted predicate to consume.

\subsubsection{Examples}

We can have two both semantics of \lstinline|≋-trans| by supplying different
signatures.

\begin{lstlisting}
≋-trans-ℕ : Set
≋-trans-ℕ = ⟦ ≋-trans ⟧P ℕ-sig []

≋-trans-Numeral : (b d : ℕ) → True (Continuous? b d 0) → Set
≋-trans-Numeral b d prop
    = ⟦ ≋-trans ⟧P (Numeral-sig b d prop) []
\end{lstlisting}

\scm{Say what they respecitvely expand to?}

\section{Converting between Semantics of \lstinline|ℕ| and \lstinline|Numeral|}


\subsection{Terms}

We start from proving that both semantics of terms are equal after evaluation.

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
toℕ-term-homo : ∀ {b d n}
    → (cont : True (Continuous? b d 0))
    → (t : Term n)
    → (env : Vec (Numeral b d 0) n)
    → ⟦ t ⟧T ℕ-sig (map ⟦_⟧ env) ≡ ⟦ ⟦ t ⟧T (Numeral-sig b d cont) env ⟧
toℕ-term-homo     cont (var i)   env = lookup-map ⟦_⟧ env i
toℕ-term-homo {b} {d} cont (t₁ + t₂) env
    rewrite toℕ-term-homo cont t₁ env
          | toℕ-term-homo cont t₂ env
    = sym (toℕ-+-homo cont
        (⟦ t₁ ⟧T (Numeral-sig b d cont) env)
        (⟦ t₂ ⟧T (Numeral-sig b d cont) env))
\end{lstlisting}

\subsection{Predicates}

% Our final goal is to translate semantics of predicates from \lstinline|ℕ|
% to \lstinline|Numeral|.

% The reason why the index $ o $ of \lstinline|Numeral| is fixed to $ 0 $ is that
% all numeral systems are required to be surjective with respect to \lstinline|ℕ|.
%
% % Otherwise, we will face some problems when converting them to \lstinline|Numeral|


\end{document}
