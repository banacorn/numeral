\providecommand{\main}{..}
\documentclass[\main/thesis.tex]{subfiles}
\begin{document}
\chapter{Translating Propositions and Proofs}\label{translation}

In this chapter, we demonstrate how to translate propositions and proofs between
\lstinline|ℕ| and a subset of \lstinline|Numeral|.

People have put a lot of effort into proving theorems and properties on
\lstinline|ℕ| and the results are widely available.
Although \lstinline|ℕ| and \lstinline|Numeral| both share the same purpose of
representing natural numbers, all these propositions and proofs that have been
constructed of \lstinline|ℕ| are useless to \lstinline|Numeral|.
We cannot simply apply a property of \lstinline|ℕ|, say,
the commutative property of addition, on instances of \lstinline|Numeral|.

The reason behind this misery comes from the difference between so-called
\textbf{object languages} and \textbf{metalanguages}.
The relation and similarities between \lstinline|ℕ| and \lstinline|Numeral|
we have observed are expressed using some \textit{metalanguage} in our mind;
while the propositions and proofs we want to reuse are formalized with Agda,
the \textit{object language} we have been dwelling on.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
        \begin{tikzpicture}

            % the frame
            \path[clip] (0, -3) rectangle (12, 3);

            % UR
            \draw[ultra thick] (1, 1) rectangle (11,3);
            \node at (6, 2) {underlying representation of propositions};

            % SR
            \draw[ultra thick] (1, -1) rectangle (5,-3);
            \node[text width=5cm, scale=0.8, align=center] at (3, -2)
                {surface representation of propositions of \lstinline|ℕ|};

            % SR
            \draw[ultra thick] (7, -1) rectangle (11,-3);
            \node[text width=5cm, scale=0.8, align=center] at (9, -2)
                {surface representation of propositions of \lstinline|Numeral|};


            % the border line
            \node[right] at (0, 0.5) {in our mind};
            \draw[dotted, ultra thick] (0,0) -- (12,0);
            \node[right] at (0, -0.5) {in Agda};

            \draw[->, ultra thick] (3, -0.9) -- (3, 0.9);
            \draw[->, ultra thick] (9, 0.9) -- (9, -0.9);

        \end{tikzpicture}
    \end{adjustbox}
\end{center}

When we are proving propositions of \lstinline|Numeral| base on the ones that
already existed on \lstinline|ℕ|, we are actually translating propositions via
some metalanguage in our mind.

To free ourselves from these brainworks, we can encode the
underlying representation of propositions in Agda,
so that we can manipulate and translate them with the
help of constructions such as functions available from the object language.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
        \begin{tikzpicture}

            % the frame
            \path[clip] (0, -4) rectangle (12, 5);

            % UR
            \draw[ultra thick] (1, 1) rectangle (11,3);
            \node at (6, 2) {underlying representation of propositions};

            % SR
            \draw[ultra thick] (1, -1) rectangle (5,-3);
            \node[text width=5cm, scale=0.8, align=center] at (3, -2)
                {surface representation of propositions of \lstinline|ℕ|};

            % SR
            \draw[ultra thick] (7, -1) rectangle (11,-3);
            \node[text width=5cm, scale=0.8, align=center] at (9, -2)
                {surface representation of propositions of \lstinline|Numeral|};

            % the border line
            \draw[dotted, ultra thick] (0,4) -- (12,4);
            \node[right] at (0, 3.5) {in Agda};

            \draw[->, ultra thick] (3, -0.9) -- (3, 0.9);
            \draw[->, ultra thick] (9, 0.9) -- (9, -0.9);

        \end{tikzpicture}
    \end{adjustbox}
\end{center}

The underlying representation of propositions can be encoded in Agda
using a generic programming technique called \textit{universe construction}
\cite{norell2009dependently}.

\section{Universe Constructions}

A universe is a set of types;
a universe construction is consists of:

\begin{itemize}
    \item A universe
    \item A datatype of ``codes''
    \item A decoding function mapping ``codes'' to the types in the universe
\end{itemize}

\subsection{A Simple Universe}

There is an universe construction we are familiar with: the universe
of \lstinline|⊤| and \lstinline|⊥|.

\subsubsection{Types}

\begin{lstlisting}
data ⊤ : Set where
    tt : ⊤
data ⊥ : Set where
\end{lstlisting}

\subsubsection{Codes}

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

\subsubsection{Decoder}

\begin{lstlisting}
isTrue : Bool → Set
isTrue true  = ⊤
isTrue false = ⊥
\end{lstlisting}

As we have shown, we can use this universe to implement, for instance, a safe
\lstinline|head| function that cannot be type-checked on empty inputs.

\begin{lstlisting}
null : ∀ {A} → (xs : List A) → Bool
null []       = true
null (x ∷ xs) = false

not : Bool → Bool
not true  = false
not false = true

head : ∀ {A} → (xs : List A) → isTrue (not (null xs)) → A
head []       ()
head (x ∷ xs) proof = x
\end{lstlisting}

We can generate the codes from \lstinline|null|,
manipulate the code with \lstinline|not|,
and finally, realize them to \lstinline|⊤| or \lstinline|⊥| with \lstinline|isTrue|.

\subsection{Summary}

Below is a table that sums up the correspondences of universe construction.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{ l l l l l }
    universe & corresponds to & surface representation & corresponds to & semantics \\
    codes & corresponds to & underlying representation & corresponds to & syntax \\
    decoder & corresponds to & realization & corresponds to & interpretation \\
    \end{tabular}
    \end{adjustbox}
\end{center}

\section{First-order Logic on the Representations of Natural Numbers}

\paragraph{Remark}
What we meant by ``proposition'' in this chapter has a broader sense than that in
\textit{propositional logic}. It also includes ``predicates'' that have
quantifiers ranging over.

To translate propositions (and predicates) from \lstinline|ℕ| to
\lstinline|Numeral| (or vice versa),
we need an underlying syntax for expressing these propositions.
For that matter, we will demonstrate how to build a minimalistic first-order logic
with universe constructions.

\subsection{Overview}

There are many kinds of propositions we can make on natural numbers.
However, we will target only at the propositions that can be expressed in both
\lstinline|ℕ| and \lstinline|Numeral|.
Therefore the terms will only consist of variables ranging over
the \textit{domain of discourse}, i.e., \lstinline|ℕ| or \lstinline|Numeral|,
and the addition function on that domain. Here is an example of a term
with three variables and two addition:

\begin{lstlisting}
x + (y + z)
\end{lstlisting}

Glueing two terms with equality connectives gives us a predicate:

\begin{lstlisting}
(x + y) + z ≈ x + (y + z)
\end{lstlisting}

Glueing two predicates with implication connectives also gives us a predicate:

\begin{lstlisting}
x ≈ y → y ≈ y
\end{lstlisting}

We can also make a new predicate by quantifying over one of its
free variables.

\begin{lstlisting}
∀ x . x ≈ y → y ≈ y
\end{lstlisting}


\subsection{Syntax}

Syntax and semantics are two key parts of first-order logic.
The syntax corresponds to the codes in a universe construction.

\subsubsection{Terms}

\begin{lstlisting}
data Term : ℕ → Set where
    var : ∀ {n} → Fin n → Term n
    add : ∀ {n} → Term n → Term n → Term n
\end{lstlisting}

The code for terms is indexed by a \lstinline|ℕ| which denotes the number
of \textit{free variables} that may occur in a predicate.
The \lstinline|Fin n| that \lstinline|var| takes designates the quantifier it is
binded to.

\subsubsection{Predicates}

\begin{lstlisting}
data Predicate : ℕ → Set where
    _≋P_ : ∀ {n} → (t₁ : Term n) → (t₂ : Term n) → Predicate n
    _→P_ : ∀ {n} → (p₁ : Predicate n) → (p₂ : Predicate n)
         → Predicate n
    ∀P   : ∀ {n} → (p : Predicate (suc n)) → Predicate n
\end{lstlisting}

The code for predicates is also indexed by the number of \textit{free variables}.
\lstinline|_≋P_| and \lstinline|_→P_| correspond to equality and  implication
connectives respectively.
It is worth nothing that \lstinline|∀P| returns a predicate with a smaller index
because one of the free variable of the given predicate has been bound.

\subsection{Semantics}

% The semantics corresponds to the types of a universe construction.

\subsubsection{Signatures}
\subsubsection{Environment of Variables}
\subsubsection{Terms}
\subsubsection{Predicates}


% \subsection{Predicates}
%
% There are two kinds of connectives: \textit{implication} and \textit{equality},
% that can glue predicates together. We can also make a new predicate out of an
% old one with free variables with an \textit{universal quantifier}.



% There are two parts of this first-order logic: syntax and semantics.




% There are two parts of propositions.
% The syntax (the codes, the underlying representation) and the semantics (the types
% of the universe, the surface representation).



% Suppose we are going to describe propositions about the things that we have
% constructed: \lstinline|Numeral| and the addition function on \lstinline|Numeral|.


% There are many kinds of propositions we can assert on natural numbers,
% We are going to


% talk about the things that has been constructed

% Suppose


% \begin{lstlisting}
% record Signature : Set₁ where
%     constructor sig
%     field
%         carrier : Set
%         _⊕_ : carrier → carrier → carrier
%         _≈_ : carrier → carrier → Set
% \end{lstlisting}
%
%
% \begin{lstlisting}
% ℕ-sig : Signature
% ℕ-sig = sig ℕ _+_ _≡_
%
% Numeral-sig : (b d : ℕ) → True (Continuous? b d 0) → Signature
% Numeral-sig b d cont = sig (Numeral b d 0) (_⊹_ {cont = cont}) _≋_
% \end{lstlisting}
%
%
% \section{Terms, Predicates and Signatures}
%
% \begin{lstlisting}
% Env : Set → ℕ → Set
% Env = Vec
% \end{lstlisting}
%
% \begin{lstlisting}
% ⟦_⟧T : ∀ {n}
%     → Term n
%     → (sig : Signature)
%     → Vec (carrier sig) n
%     → carrier sig
% ⟦ var i         ⟧T _                env = lookup i env
% ⟦ term₁ ∔ term₂ ⟧T (sig A _⊕_ _≈_) env = ⟦ term₁ ⟧T (sig A _⊕_ _≈_) env ⊕ ⟦ term₂ ⟧T (sig A _⊕_ _≈_) env
% \end{lstlisting}
%
% \begin{lstlisting}
% \end{lstlisting}

\end{document}
