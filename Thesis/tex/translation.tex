\providecommand{\main}{..}
\documentclass[\main/thesis.tex]{subfiles}
\begin{document}
\chapter{Translating Propositions and Proofs}\label{translation}

In this chapter, we demonstrate how to translate propositions and proofs between
\lstinline|ℕ| and a subset of \lstinline|Numeral|.

People have put a lot of effort into proving theorems and properties on
\lstinline|ℕ| and the results are widely available.
Although \lstinline|ℕ| and \lstinline|Numeral| both share the same purpose of
representing natural numbers, all these propositions and proofs that have been
constructed of \lstinline|ℕ| are useless to \lstinline|Numeral|.
We cannot simply apply a property of \lstinline|ℕ|, say,
the commutative property of addition, on instances of \lstinline|Numeral|.

The reason behind this misery comes from the difference between so-called
\textbf{object languages} and \textbf{metalanguages}.
The relation and similarities between \lstinline|ℕ| and \lstinline|Numeral|
we have observed are expressed using some \textit{metalanguage} in our mind;
while the propositions and proofs we want to reuse are formalized with Agda,
the \textit{object language} we have been dwelling on.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
        \begin{tikzpicture}

            % the frame
            \path[clip] (0, -3) rectangle (12, 3);

            % UR
            \draw[ultra thick] (1, 1) rectangle (11,3);
            \node at (6, 2) {underlying representation of propositions};

            % SR
            \draw[ultra thick] (1, -1) rectangle (5,-3);
            \node[text width=5cm, scale=0.8, align=center] at (3, -2)
                {surface representation of propositions of \lstinline|ℕ|};

            % SR
            \draw[ultra thick] (7, -1) rectangle (11,-3);
            \node[text width=5cm, scale=0.8, align=center] at (9, -2)
                {surface representation of propositions of \lstinline|Numeral|};


            % the border line
            \node[right] at (0, 0.5) {in our mind};
            \draw[dotted, ultra thick] (0,0) -- (12,0);
            \node[right] at (0, -0.5) {in Agda};

            \draw[->, ultra thick] (3, -0.9) -- (3, 0.9);
            \draw[->, ultra thick] (9, 0.9) -- (9, -0.9);

        \end{tikzpicture}
    \end{adjustbox}
\end{center}

When we are proving propositions of \lstinline|Numeral| base on the ones that
already existed on \lstinline|ℕ|, we are actually translating propositions via
some metalanguage in our mind.

To free ourselves from these brainworks, we can encode the
underlying representation of propositions in Agda,
so that we can manipulate and translate them with the
help of constructions such as functions available from the object language.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
        \begin{tikzpicture}

            % the frame
            \path[clip] (0, -4) rectangle (12, 5);

            % UR
            \draw[ultra thick] (1, 1) rectangle (11,3);
            \node at (6, 2) {underlying representation of propositions};

            % SR
            \draw[ultra thick] (1, -1) rectangle (5,-3);
            \node[text width=5cm, scale=0.8, align=center] at (3, -2)
                {surface representation of propositions of \lstinline|ℕ|};

            % SR
            \draw[ultra thick] (7, -1) rectangle (11,-3);
            \node[text width=5cm, scale=0.8, align=center] at (9, -2)
                {surface representation of propositions of \lstinline|Numeral|};

            % the border line
            \draw[dotted, ultra thick] (0,4) -- (12,4);
            \node[right] at (0, 3.5) {in Agda};

            \draw[->, ultra thick] (3, -0.9) -- (3, 0.9);
            \draw[->, ultra thick] (9, 0.9) -- (9, -0.9);

        \end{tikzpicture}
    \end{adjustbox}
\end{center}

The underlying representation of propositions can be encoded in Agda
using a generic programming technique called \textit{universe construction}
\cite{norell2009dependently}.

\section{Universe Constructions}

A universe is a set of types;
a universe construction is consists of:

\begin{itemize}
    \item A universe
    \item A datatype of ``codes''
    \item A decoding function mapping ``codes'' to the types in the universe
\end{itemize}

\subsection{A Simple Universe}

There is an universe construction we are familiar with: the universe
of \lstinline|⊤| and \lstinline|⊥|.

\subsubsection{Types}

\begin{lstlisting}
data ⊤ : Set where
    tt : ⊤
data ⊥ : Set where
\end{lstlisting}

\subsubsection{Codes}

\begin{lstlisting}
data Bool : Set where
    true  : Bool
    false : Bool
\end{lstlisting}

\subsubsection{Decoder}

\begin{lstlisting}
isTrue : Bool → Set
isTrue true  = ⊤
isTrue false = ⊥
\end{lstlisting}

As we have shown, we can use this universe to implement, for instance, a safe
\lstinline|head| function that cannot be type-checked on empty inputs.

\begin{lstlisting}
null : ∀ {A} → (xs : List A) → Bool
null []       = true
null (x ∷ xs) = false

not : Bool → Bool
not true  = false
not false = true

head : ∀ {A} → (xs : List A) → isTrue (not (null xs)) → A
head []       ()
head (x ∷ xs) proof = x
\end{lstlisting}

We can generate the codes from \lstinline|null|,
manipulate the code with \lstinline|not|,
and finally, realize them to \lstinline|⊤| or \lstinline|⊥| with \lstinline|isTrue|.

\subsection{Summary}

Below is a table that sums up the correspondences of universe construction.

\begin{center}
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{ l l l l l }
    universe & corresponds to & surface representation & corresponds to & semantics \\
    codes & corresponds to & underlying representation & corresponds to & syntax \\
    decoder & corresponds to & realization & corresponds to & interpretation \\
    \end{tabular}
    \end{adjustbox}
\end{center}

\section{First-order Logic on the Representations of Natural Numbers}

\paragraph{Remark}
What we meant by ``proposition'' in this chapter has a broader sense than that in
\textit{propositional logic}. It also includes ``predicates'' that have
quantifiers ranging over.

To translate propositions (and predicates) from \lstinline|ℕ| to
\lstinline|Numeral| (or vice versa),
we need an underlying syntax for expressing these propositions.
For that matter, we will demonstrate how to build a minimalistic first-order logic
with universe constructions.

\subsection{Overview}

There are many kinds of propositions we can make on natural numbers.
However, we will target only at the propositions that can be expressed in both
\lstinline|ℕ| and \lstinline|Numeral|.
Therefore the terms will only consist of variables ranging over
the \textit{domain of discourse}, i.e., \lstinline|ℕ| or \lstinline|Numeral|,
and the addition function on that domain. Here is an example of a term
with three variables and two addition:

\begin{lstlisting}
x + (y + z)
\end{lstlisting}

Glueing two terms with equality connectives gives us a predicate:

\begin{lstlisting}
(x + y) + z ≈ x + (y + z)
\end{lstlisting}

Glueing two predicates with implication connectives also gives us a predicate:

\begin{lstlisting}
x ≈ y → y ≈ y
\end{lstlisting}

We can also make a new predicate by quantifying over one of its
free variables.

\begin{lstlisting}
∀ x . x ≈ y → y ≈ y
\end{lstlisting}


\subsection{Syntax}

Syntax and semantics are two key parts of first-order logic.
The syntax corresponds to the codes in a universe construction.
There are two datatypes for codes, one for \textit{terms} and the another for
\textit{predicates}.

\subsubsection{Terms}

\begin{lstlisting}
data Term : ℕ → Set where
    var : ∀ {n} → Fin n → Term n
    add : ∀ {n} → Term n → Term n → Term n
\end{lstlisting}

The code for terms is indexed by a \lstinline|ℕ| which denotes the number
of \textit{free variables} that may occur in a predicate.
The \lstinline|Fin n| that \lstinline|var| takes designates the quantifier it is
binded to.

\subsubsection{Predicates}

\begin{lstlisting}
data Predicate : ℕ → Set where
    _≋P_ : ∀ {n} → (t₁ : Term n) → (t₂ : Term n) → Predicate n
    _→P_ : ∀ {n} → (p₁ : Predicate n) → (p₂ : Predicate n)
         → Predicate n
    ∀P   : ∀ {n} → (p : Predicate (suc n)) → Predicate n
\end{lstlisting}

The code for predicates is also indexed by the number of \textit{free variables}.
\lstinline|_≋P_| and \lstinline|_→P_| correspond to equality and  implication
connectives respectively.
It is worth noting that \lstinline|∀P| returns a predicate with a smaller index
because one of the free variable of the given predicate has been bound.

\subsection{Semantics}

The semantics determine meanings behind these propositions, and by meanings
we mean the selection of types of the universe we are constructing.

\subsubsection{Signatures}

A syntax can be interpreted as many different semantics.
Each semantics has its own choice of interpreting a piece of syntax,
we call these choices a \textit{signature}.
That is to say, each semantics has its own signature.

The datatype of signature can defined as follows:

\begin{lstlisting}
record Signature : Set₁ where
    constructor sig
    field
        carrier : Set
        _⊕_ : carrier → carrier → carrier
        _≈_ : carrier → carrier → Set
\end{lstlisting}

Different semantics have different signatures.

\begin{lstlisting}
ℕ-sig : Signature
ℕ-sig = sig ℕ _+_ _≡_

Numeral-sig : (b d : ℕ) → True (Continuous? b d 0) → Signature
Numeral-sig b d cont = sig (Numeral b d 0) (_+_ {cont = cont}) _≋_
\end{lstlisting}

% The index $ o $ is fixed to $ 0 $ because the systems would have to be surjective
% with respect to \lstinline|ℕ|
% \lstinline|Numeral-sig| is a function that returns signatures when given the

Note that \lstinline|ℕ-sig| and \lstinline|Numeral-sig| are equipped with
different equality connectives.
The one equipped by \lstinline|Numeral-sig| is defined as follows:

\begin{lstlisting}
_≋_ : ∀ {b d o}
    → (xs ys : Numeral b d o)
    → Set
xs ≋ ys = ⟦ xs ⟧ ≡ ⟦ ys ⟧
\end{lstlisting}

We need a different type for equality because systems of \lstinline|Numeral|
may be redundant, that is, two numerals may look different to \lstinline|_≡_|
even if they both evaluates to the same number.

Also, the index $ o $ of \lstinline|Numeral| is fixed to $ 0 $.
We will explain why the domain of discourse is limited that way in the
later section.

\subsubsection{Meaning of Variables}

Terms and predicates can have free variables, but variables are given
meanings only when they are substituted.

\begin{lstlisting}
var : ∀ {n} → (i : Fin n) → Term n
\end{lstlisting}

\lstinline|var| have to choose a number $ i $ of \lstinline|Fin n| as its name,
because values of all variables are stored in a \lstinline|Vec n| (a list of length $ n $.)
Upon substitution, we choose the $ i $th element of the list as its value.

\subsubsection{Interpreting Terms}

The interpreter of the syntax for terms is defined as follows:

\begin{lstlisting}
⟦_⟧T : ∀ {n}
    → Term n
    → (sig : Signature)
    → Vec (carrier sig) n
    → carrier sig
\end{lstlisting}

\lstinline|carrier sig| evaluates to the carrier of the signature, the domain
of discours. For example, \lstinline|carrier ℕ-sig| evaluates to \lstinline|ℕ|.
In addition to the term, \lstinline|⟦_⟧T| also takes a signature, meanings of
all variables, and returns an element of the carrier.

\begin{lstlisting}
⟦ var i ⟧T _ env = lookup i env
\end{lstlisting}

In the case of \lstinline|var|,
\lstinline|lookup| retrieves the $i$th value for the variable from \lstinline|env|.
This is where the variable substitution happens.

\begin{lstlisting}
⟦ add term₁ term₂ ⟧T sig env
    = ⟦ term₁ ⟧T sig env ⊕ ⟦ term₂ ⟧T sig env
\end{lstlisting}

In the case of \lstinline|add|,
the semantics of both terms are interpreted recursively,
and then computed with \lstinline|_⊕_|,
the addition function supplied by the signature.

\subsubsection{Interpreting Predicates}

The interpreter of the syntax for predicates is defined as follows:

\begin{lstlisting}
⟦_⟧P : ∀ {n}
    → Predicate n
    → (sig : Signature)
    → Env (carrier sig) n
    → Set
\end{lstlisting}

Similar to interpreting terms, except that \lstinline|⟦_⟧P| returns a \textit{type}.

\begin{lstlisting}
⟦ t₁ ≋P t₂ ⟧P sig env
    = ⟦ t₁ ⟧T sig env ≈ ⟦ t₂ ⟧T sig env
\end{lstlisting}

In the case of \lstinline|_≋P_|,
the semantics of both terms are interpreted using \lstinline|⟦_⟧T|.
\lstinline|_≈_| is the equality connective supplied by the signature.


\begin{lstlisting}
⟦ p →P q   ⟧P signature env = ⟦ p ⟧P signature env → ⟦ q ⟧P signature env
\end{lstlisting}

In the case of \lstinline|_→P_|,
the semantics of both predicates are interpreted recursively.

\begin{lstlisting}
⟦ ∀P pred  ⟧P signature env = ∀ x → ⟦ pred ⟧P signature (x ∷ env)
\end{lstlisting}


% \subsection{Predicates}
%
% There are two kinds of connectives: \textit{implication} and \textit{equality},
% that can glue predicates together. We can also make a new predicate out of an
% old one with free variables with an \textit{universal quantifier}.



% There are two parts of this first-order logic: syntax and semantics.




% There are two parts of propositions.
% The syntax (the codes, the underlying representation) and the semantics (the types
% of the universe, the surface representation).



% Suppose we are going to describe propositions about the things that we have
% constructed: \lstinline|Numeral| and the addition function on \lstinline|Numeral|.


% There are many kinds of propositions we can assert on natural numbers,
% We are going to


% talk about the things that has been constructed

% Suppose

%
% \begin{lstlisting}
% ℕ-sig : Signature
% ℕ-sig = sig ℕ _+_ _≡_
%
% Numeral-sig : (b d : ℕ) → True (Continuous? b d 0) → Signature
% Numeral-sig b d cont = sig (Numeral b d 0) (_⊹_ {cont = cont}) _≋_
% \end{lstlisting}
%
%
% \section{Terms, Predicates and Signatures}
%
% \begin{lstlisting}
% Env : Set → ℕ → Set
% Env = Vec
% \end{lstlisting}
% \begin{lstlisting}
% \end{lstlisting}

\end{document}
