\providecommand{\main}{..}
\documentclass[\main/thesis.tex]{subfiles}
\begin{document}
\chapter{Translating Propositions and Proofs}\label{translation}

In this chapter, we demonstrate how to translate propositions and proofs between
\lstinline|ℕ| and a subset of \lstinline|Numeral|.

People have put a lot of effort into proving theorems and properties on
\lstinline|ℕ| and the results are widely available.
Although \lstinline|ℕ| and \lstinline|Numeral| both share the same purpose of
representing natural numbers, all these propositions and proofs of \lstinline|ℕ|
are useless for \lstinline|Numeral|.
We cannot simply apply a property of \lstinline|ℕ|, say,
the commutative property of addition, on instances of \lstinline|Numeral|.

The reason behind this misery comes from the difference between so-called
\textbf{object languages} and \textbf{metalanguages}.
The relation and similarities between \lstinline|ℕ| and \lstinline|Numeral|
we have observed are expressed using a \textit{metalanguage}, English, in our case;
while the propositions and proofs we want to reuse are formalized with Agda,
the \textit{object language} we have been dwelling on.

% To reuse 


% Because the relation and similarities between these two representations we have
% observed and described are uttered with a \textit{metalanguage} (English, in
% this case), while those proofs are often written in some \textit{object language}.
% We will demonstrate how to \textit{encode} propositions expressed in the
% metalanguage to an object language that we have constructed and how to manipulate
% them

\section{Universe Constructions}



\section{Terms, Predicates and Signatures}


\begin{lstlisting}
data Term : ℕ → Set where
    var : ∀ {n} → Fin n → Term n
    add : ∀ {n} → Term n → Term n → Term n
\end{lstlisting}

\begin{lstlisting}
data Predicate : ℕ → Set where
    _≋P_ : ∀ {n} → (t₁ : Term n) → (t₂ : Term n) → Predicate n
    _→P_ : ∀ {n} → (p₁ : Predicate n) → (p₂ : Predicate n) → Predicate n
    ∀P : ∀ {n} → (p : Predicate (suc n)) → Predicate n
\end{lstlisting}

\section{}

\begin{lstlisting}
record Signature : Set₁ where
    constructor sig
    field
        carrier : Set
        _⊕_ : carrier → carrier → carrier
        _≈_ : carrier → carrier → Set
\end{lstlisting}


\begin{lstlisting}
ℕ-sig : Signature
ℕ-sig = sig ℕ _+_ _≡_

Numeral-sig : (b d : ℕ) → True (Continuous? b d 0) → Signature
Numeral-sig b d cont = sig (Numeral b d 0) (_⊹_ {cont = cont}) _≋_
\end{lstlisting}


\section{Terms, Predicates and Signatures}

\begin{lstlisting}
Env : Set → ℕ → Set
Env = Vec
\end{lstlisting}

\begin{lstlisting}
⟦_⟧T : ∀ {n}
    → Term n
    → (sig : Signature)
    → Vec (carrier sig) n
    → carrier sig
⟦ var i         ⟧T _                env = lookup i env
⟦ term₁ ∔ term₂ ⟧T (sig A _⊕_ _≈_) env = ⟦ term₁ ⟧T (sig A _⊕_ _≈_) env ⊕ ⟦ term₂ ⟧T (sig A _⊕_ _≈_) env
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\end{document}
